1주차

- 모듈의 세 가지 목적 : 작동, 변경이 쉽게, 이해가 쉽게
- 객체지향 프로그래밍을 하면 '변경이 쉽게' 와 '이해가 쉽게'를 만족시키기 좋다.
- 바로 데이터(property)와 그 데이터를 하나의 객체에서 다룸으로써, 객체 각각의 자율성을 보장하고  책임을 분산하는 것
- 이는 객체지향에서 '결합도'를 낮춘다, '응집도'를 높인다, '캡슐화'를 한다, '인터페이스'를 이용한다는 행위와 일맥상통.
- 하지만, Trade off를 고려하여 자율성과 결합도 간의 높낮이를 적절히 유지하는 것이 좋다.

ps)

- 데이터와 그 데이터를 하나의 객체에서 다루는 것, 즉 하나의 모듈에서 다루는 것이 객체지향의 전부는 아니다. 진정한 객체지향은 객체에 적절한 역할을 부여하는 것. 차차 알아가보자.
- '이해가 쉽게'라는 부분을, 책에서는 실생활과 접목시켜 설명하려 하지만 나는 이해가 잘 안되는 부분이다. 의인화가 실생활에서 설명이 잘 되는가? 나는 이해가 잘 되는 코드는 하나의 클래스에 적절한 코드가 잘 배치된, 역할이 잘 분배된 객체를 이해가 잘 되는 코드라고 생각한다. 즉 객체간 depth가 너무 깊으면 이해가 되지 않는 코드라고 생각한다.
- 이어 말하면, 절차지향적 코드 또한 무조건 안 좋은 코드라고 생각하지 않는다. 실제로 테스트 코드를 짤 때는 더 쉬울 수도 있다는 스터디원의 의견도 있었다. 적절한 패러다임의 조화가 필요한 시점이라고 생각된다(디자인 패턴 등을 통해서 말이지...)
- 스터디에서 나왔던 말 중에, 변화에 유연한 것과 확장성이 좋은 건 다른 표현일 수 있다는 얘기가 있었다. 맞는 말이라 생각된다.

2주차

프로그래밍 개념이 많이 들어있는 장.

part 2)

- `진정한 객체지향 패러다임으로의 전환은 클래스가 아닌 객체에 초점을 맞출 때에만 얻을 수 있다.`
    - 객체들의 모양과 윤곽을 잡음(협력 관계 속) → 공통된 특성과 상태를 가진 객체들을 타입으로 분류하고, 이 타입을 기반으로 클래스를 구현 (협력 → 객체 → 클래스)

- 클래스의 내부와 외부를 구분 (주로 접근제한자를 통해)
    - 캡슐화
    - 외부에서 접근 가능한 부분을 인터페이스로, 내부는 구현이라 칭함.
    - 이는 객체를 자율적인 존재로 만듬(스스로 생각하도록)
    - 또한 구현 은닉을 통해 프로그래머의 자유를 보장(이해안됨잘)
- 객체지향 프로그래밍 언어에서 DDD가 유리한 이유 → 도메인을 객체로 접근이 가능하기 떄문.

part 4)

상속과 다형성에 대한 이야기

- 메소드를 호출하는 것이 아니라, 메시지를 전달함.
- 그것이 가능한 것은, 객체지향 프로그래밍 언어에서 객체는 컴파일 시간 의존성이 아닌 실행 시간 의존성을 가지기 때문 (코드의 의존성과 객체 사이의 의존성이 다름)(지연(동적) 바인딩)
- 이것이 바로 '다형성'
- 이는 '유연성'과 '이해도'의 Trade Off를 불러일으킨다.
- 추가로, 추상 클래스를 이용한 Template method 디자인 패턴에 대한 이야기
- 다형성은 동일한 인터페이스를 전제로 하므로, 상속을 활용하면 좋지만 이게 다는 아니다.
- p63이 핵심!

part 5)

추상화에 대한 이야기

- 더 애매한 것 → 더 추상적인 것 → 더 포괄적인 것. 추상클래스 또한 동일하다.(p66)
- 그래서 추상화를 통해 기본적인 어플리케이션 협력 흐름을 기술할 수 있는 것.
- 추상화를 통해 코드의 확장이 유연해짐.
- 예외케이스를 최소화 하고, 객체화 시키는 것이 좋다.(일관적인 객체의 역할을 유지)
- 컨텍스트 독립성(8장)
- 코드의 재사용은 '상속'이 아닌 '합성'을 이용하는 것이 바람직하다.
- 포함 된 객체의 인터페이스에 정의된 메시지를 통해서만 코드를 재 사용하기 때문에, 구현의 캡슐화와 설계의 유연성을 보장.
- 상속은 다형성을 위한 인터페이스의 재사용 용도로 쓰는 것이 좋다.

ps) 스터디 토론

- 추상클래스의 존재 의의에 대한 스터디 토론이 있었다. 최근 자바에서도 인터페이스의 디폴트메서드 때문에 추상클래스의 입지가 작아지고 있는 추세.
- money 클래스가 필요할까? 실제로 사용하는 예시를 보지 못했다고 한다.
- 다형성이란, 동일한 메세지를 통해 다른 결과를 얻어내는 것.
- 객체지향적 관점과, 프로그래밍 언어 속 객체지향을 위한 기능들(클래스, 상속)을 책에서는 다르게 본다.

3장

역할, 책임, 협력에 대한 설명

- 2장의 상속, 지연 바인딩 등은 구현 메커니즘일 뿐 객체지향 패러다임의 본질과는 거리가 멀다.
- 진정한 객체지향의 핵심은 역할, 책임, 협력
    - 협력 : 기능 수행을 위한 객체간의 상호 작용
    - 책임 : 객체가 협력에 참여하기위해(참여하며) 수행하는 로직
    - 역할 : 책임의 집합

part 1) 협력

- 의존성의 추상화
- 메시지 전송 → 메서드 실행
- 협력을 위해 행동(메서드)가 필요하고, 메서드를 위해 상태(property)가 필요

part 2) 책임

- 객체의 추상화
- 책임이란 객체 행위의 집합이며, 객체가 유지해야 하는 정보(상태)와 수행할 수 있는 행동(행동)에 대해 개략적으로 서술한 문장.
- 하는 것(doing)과 아는 것(knowing) 두 가지로 나뉨
- 책임이 객체지향 설계에서 가장 중요하다.
- 객체의 구현 방법은 상대적으로 책임보다 덜 중요하며, 책임을 결정한 다음에 고민해도 늦지 않다.
- 책임 주도 설계 : 시스템의 기능을 하나의 큰 책임으로 보고, 책임을 해결하기 위해 협력의 관점에서 작은 책임으로 나눈 뒤, 이를 객체들에게 할당하는 과정(인터페이스에 역할을 할당) → 인터페이스와 오퍼레이션 목록이 정해져, 추상화 된 프로세스를 얻을 수 있다.
- 상태는 행동을 위한 재료이므로, 설계 단계에서 행동 위주로 설계하고, 상태는 부수적으로 따라오게 만든다.

part 3) 역할

- 인터페이스 또는 추상클래스의 추상화
- 특정 협력 안에서 수행하는 책임의 집합
- 객체에 책임을 부여하는 것이 아닌, 역할에 책임을 부여하자. (책임 → 역할 → 객체)
- 지연 로딩(다형성)을 통해 역할을 객체로 구체화
- 협력 → 역할 → 객체 → 클래스
- 객체는 다양한 협력 속에서 각 협력 당 (일반적으로)하나의 역할을 가진다(배우와 배역)

ps) 구체적인 방법이 아닌, 개념을 잡아주는 책이라 생각하자

## 3장

### 설계와 캡슐화, 응집도, 결합도

- 설계는 변경이 용이한 어플리케이션을 만들기 위한 것!
- 변경은 캡슐화, 응집도, 결합도와 관련있다.
- 그러므로 설계는 캡슐화, 응집도, 결합도와 관련있다.

캡슐화 :

- 구현과 인터페이스를 분리하고, 인터페이스만 노출 시키는 것.
- *** 변경 가능성이 있는 모든 것을 캡슐화 해야한다.

응집도 :

- 높은 응집도란 하나의 변경에 하나의 모듈 전체가 바뀌는 것,
- 낮은 응집도는 하나의 변경에 여러 모듈 일부가 바뀌는 것.

결합도 :

- 낮은 결합도란  모듈 변경 시 다른 모듈에 영향이 최소화 되는 것.
- 또는 내부 구현이 아닌 인터페이스의 변경만이 다른 모듈에 변경을 일으킬 때
- 캡슐화, 응집도, 결합도의 관점에서 변경에 유리한 설계를 하는 것이 이번 장의 핵심.
- 그렇게 하기 위해서는, 데이터 중심이 아닌 책임 중심의 설계가 필요하다.

### 역할 중심 설계와 데이터 중심 설계

상태는 구현에 속해있으며, 불안정하고 변하기 쉽다.

책임은 인터페이스에 속해 있어 안정적이다.

- 역할 중심 설계

협력 → 인터페이스 → 구현

- 데이터 중심 설계

구현 → 인터페이스 → 협력

데이터 중심의 설계는 문맥에 대한 고려 없이 구현이 먼저 이루어지기 때문에, 인터페이스가 구현에 맞춰지게 되고 그럼으로써 내부 구현이 외부로 노출되게 된다.

외부로 노출 된 구현이란 캡슐화 위반, 모듈간의 결합도 증가, 응집도 감소라는 결과를 낳으며 이는 변화에 취약한 프로그래밍으로 이어진다.

객체 내부의 구현에 다른 코드가 침입하거나, 인터페이스에 구현이 들어가 있는 경우가 캡슐화 실패를 의미하며 이는 데이터 중심의 설계에서 나타난다.

그러므로, 데이터 중심 설계가 아닌 역할 중심의 설계, 상태가 아닌 행동, 클래스가 아닌 협력에 중점을 두고 설계하자~

PS)

- 진정한 캡슐화란 구현과 관련해 변할 수 있는 모든 것을 감추는 것이다.
- 파라미터, 메소드의 개수나 이름으로 상태를 노출하는 것(데이터의 정보가 인터페이스에 노출된 경우) 또한 캡슐화를 위반하는 것이다.
- 안정도가 높으면 응집도, 결합도는 크게 상관 없을 수 있다.
- getter, setter 지양하자.

getter, setter 남발하는 것은 추측에 의한 설계 전략이ㄴ며,  getter,setter는 구현에 간섭을 줄 여지가 많다. 또한 객체가 데이터 집합체로 전략할 수 있다.

### 스터디

Model이 Domain Entity라면, 비즈니스로직이 첨가되는게 맞다고 보나

→ 곧바로 사용하지는 않고, 모델은 데이터베이스 row의 데이터를 매핑해주는 dto로 삼고, 한 번 더 매핑해주는 객체를 생성해서 그 객체에 비즈니스 로직을 넣는다. 맨 처음 받아온 모델을 곧바로 json response로 만들 시 lazy loading 되어있던 불필요한 데이터까지 불러오는 쓸모없는 쿼리가 발생할 수 있으므로, 불필요한 데이터는 null을 넣는 새로운 객체를 사용한다고 한다.

# 5장. 책임 할당하기

### 책임 주도 개발은

- 객체에게 어떤 책임을 줄 지 가장 어렵다.
- 트레이드오프 활동이다.
- 책임의 분배를 다양한 관점에서 평가하자.

### 1. 책임 주도 설계를 향해

- 데이터보다 행동을 먼저 결정하라
- 협력이라는 문맥 안에서 책임을 결정하라
    - 책임은 객체의 입장이 아니라 객체가 참여하는 협력에 적합해야 한다.

      p147) Movie 클래스의 메서드명을 calculateFee가 아닌 calculateMovieFee로 정한 것이 그 예시가 될 수 있다.

    - 즉, 메시지의 수신자가 아니라 발신자(클라이언트)에게 적합한 책임이어야 한다.
    - 클라이언트가 발신할 메시지를 선택하고, 그 메시지를 처리할 객체를 선택하는 것이다. (객체가 메시지 선택 x, 메시지가 객체를 선택) (클래스 기반 설계 -> 메시지 기반 설계) (캡슐화가 자동으로 이루어짐!)
    - 데이터는 그 다음에!

### 2. 책임 할당을 위한 GRASP 패턴

1. 도메인 개념에서 출발하기
    - 구현을 가이드 할 수 있을 정도로 도메인 설계를 구상한다.(너무 자세하게는 x, 하지만 구현과 밀접한 관계를 가질 수 있게끔)
2. 정보 전문가에게 책임 할당

   도메인을 토대로

    - 메시지를 결정하고
    - 해당 메시지를 필요한 정보를 '알아낼 수 있는' '정보전문가'에게 맡김
    - 정보 전문가의 내부 로직을 대략적으로 고민하고, 외부에 도움을 요청해야 하는 경우를 판단해 새로운 메시지 결정
3. High Cohesion, Low Coupling

   책임 할당 시 항상 고려해야 하는 기본 원리

4. CREATOR 패턴

   객체의 생성을 누구에게 맡겨야 하지?

    - 생성될 객체를 포함/ 참조하거나
    - 생성될 객체를 기록하거나
    - 생성된 객체를 긴밀하게 사용하고
    - 생성될 객체의 정보전문가 객체에게
      이를 최대한 많이 충족하는 객체에게 생성을 맡기는 것

### 3. 구현을 통한 검증

1. 문제점
    - 서로 연관성이 없는 기능이나 데이터가 하나의 클래스 안에 있는 경우, 응집도가 낮다고 표현한다.
    - 응집도가 낮은 지 검증하는 세 가지 방법 :
        - 클래스가 하나 이상의 이유로 변경되는 경우
        - 클래스의 인스턴스를 초기화 하는 시점에서, 경우에 따라 서로 다른 속성들을 초기화 하는 경우(초기화 되는 속성이 일부인 경우) -> 초기화 되는 속서으이 그룹으로 클래스 분리
        - 메서드 그룹에 따라 속성 그룹이 나뉘는 경우 (메서드에 따라 속성을 일부만 사용하는 경우)
2. 타입 분리하기, 다형성 패턴 사용하기, 변경으로부터 보호하기
    - 타입별로 조건 논리를 사용해 로직을 분리하면 변화에 취약하므로, 타입별로 클래스를 나누고 다형성을 이용해 확장성을 키우자.
    - Protected Variations 패턴 -> 변경이 예측되는 부분을 캡슐화하라.

          Protected Variations == openclosed principle (SOLID ocp)

3. Movie 클래스 개선하기
    - 도메인의 구조 -> 코드의 구조화
    - 도메인 주도 개발의 내용이 파트에 잠시 언급
4. 변경과 유연성
    - 유연성을 위해 상속 대신 합성 사용

### 4.책임 주도 설계의 대안

책임 주도 설계를 순서대로 따라가기 어렵다면, 빠른 속도로 코딩한 다음 객체지향적 코드로 'Refactoring'

- 메서드 응집도 향상
    - 주석 대신 작고 응집도 강한 메서드로
    - 이해하기 쉬운 이름 사용
- 메서드를 적절한 클래스에 재 배치
    - 메서드가 사용하는 데이터를 저장하고 있는 클래스로 이동
    - 메서드가 어떤 클래스의 접근자 메서드를 사용하는지 확인하자.
    - 주로 인자에 정의된 클래스 중 하나로 이동

질문거리

1) table에 매핑되는 Entity객체를 한 번 더 매핑해서 사용하는 것이 맞나?

2) 맞다면, 매핑하는 방법은?

3) 매핑한 객체는 Entity에서 제공하는 다양한 기능을 사용하지 못하게 되지 않나?

4) 매핑한 객체에 비즈니스 로직이 들어가는게 맞나?

5) 근데, 엔티티를 그대로 반환하는게 아닌데 n+1문제가 일어날 이유가 있나? jsonresponse 메서드를 사용할 이유가 있나?

→

1) 맞다.

Entity 모델 < - > business logic이 담긴 도메인 오브젝트 < - > response dto

2) 모델 매퍼 사용

https://yonguri.tistory.com/69

https://www.baeldung.com/entity-to-and-from-dto-for-a-java-spring-application

3) 다양한 기능? 필요한 RELATION은 다 가져온다.

4) 맞다.

5)

1. 불확실성,

2. Entity 모델을 라이브러리 형태로 만들어서 다른 프로젝트에서 재사용 할 수도 이씀.

위와같은 이유로 Entity모델은 데이터베이스 dto 객체로 사용하고, 새로운 도메인 오브젝트에 매핑해서 사용한다.

# 6장. 메시지와 인터페이스

## intro

- 애플리케이션은 클래스로 구성되지만 메시지를 통해 정의된다
    - 클래스라는 구현 도구에 집착하면 경직되고 유연하지 못한 설계에 이를 수 있다.
    - 객체지향 애플리케이션의 가장 중요한 재료는 클래스가 아니라 객체, 객체의 책임, 즉 객체들이 주고 받는 메시지이다.
    - 객체가 수신하는 메시지들이 객체의 퍼블릭 인터페이스를 구성한다.
    - 이번 장에서는 훌륭한 퍼블릭 인터페이스를 만드는 데 도움이 되는 설계 원칙과 기법을 보자.

## 1. 협력과 메시지

협력과 메시지의 기본 개념 확립

### 클라이언트 - 서버 모델

- 협력은 메시지를 통해 이루어진다.
- 메시지 전송 : 클라이언트, 메시지 수신 : 서버
- 협력은 클라이언트가 서버의 서비스를 요청하는 단방향 상호작용이다.
- 대부분 객체가 수신하는 메시지의 집합에만 초점을 맞추지만, 협력에 적합한 객체를 설계하기 위해서는 외부에 전송하는 메시지의 집합도 함께 고려하는 것이 바람직하다.
- 객체가 독립적으로 수행할 수 있는 것보다 더 큰 책임을 수행하기 위해서는, 다른 객체와 협력해야 한다.

### 메시지와 메시지 전송

- 메시지, 메시지 전송, 메시지 패싱
- 메시지 전송자, 메시지 수신자
- 오퍼레이션명, 인자

### 메시지와 메서드

- 동일한 메시지라도 객체의 타입에 따라 실행 메서드가 다를 수 있다 → 객체지향에서의 코드는 컴파일 시점과 실행 시점의 의미가 달라질 수 있다.
- 메시지와 메서드의 구분은 메시지 전송자와 수신자가 느슨하게 결합될 수 있게 한다 → 실행 시점에 메시지와 메서드를 바인딩하는 메커니즘은 두 객체 사이의 결합도를 낮춤으로써 유연하고 확장 가능한 코드를 작성할 수 있게 만든다.

### 퍼블릭 인터페이스와 오퍼레이션

- 퍼블릭 인터페이스 : 객체가 외부에 공개하는 메시지의 집합
- 오퍼레이션 : 퍼블릭 인터페이스에 포함된 메시지. 수행 가능한 어떤 행동에 대한 추상화.
- 메서드 : 메시지를 수신했을 떄 실제로 실행되는 코드. 구현체
- 오퍼레이션 호출 ≠ 메서드 호출

### 시그니처

- 시그니처 : 오퍼레이션(또는 메서드)의 이름과 파라미터 목록
- 오퍼레이션의 관점에서 다형성이란, 동일한 오퍼레이션 호출에 대해 서로 다른 메서드들이 실행되는 것.
- 다형성의 축복을 받기 위해서는 하나의 오퍼레이션에 다양한 메서드를 구현해야만 한다.(하나의 오퍼레이션에 하나의 메서드만 있는 경우 굳이 구분할 필요가 없다.)
- 객체의 퍼블릭 인터페이스가 객체의 품질을 결정하기 때문에, 결국 메시지가 객체의 품질을 결정한다고 볼 수 있다.

## 2. 인터페이스와 설계 품질

- 좋은 인터페이는 최소한의 인터페이스와 추상적인 인터페이스
- 추상적인 인터페이스 : 어떻게가 아닌 무엇을 하는지를 표현
- 좋은 인터페이스 설계의 가장 좋은 방법은 책임 주도 설계 방법을 따르는 것. - 메시지를 먼저 선택하고, 메시지가 객체를 선택
- 퍼블릭 인터페이스의 품질에 영향을 미치는 원칙과 기법
    - 디미터 법칙
    - 묻지 말고 시켜라
    - 의도를 드러내는 인터페이스
    - 명령-쿼리 분리


### 디미터 법칙

- 대표 위반 사례 :

```java
screening.getMovie().getDiscountConditions();
```

- 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라.
- shy code 지향, train wreck 지양
- 캡슐화를 위해 따라야 하는 구체적인 지침
- 무비판적인 디미터 법칙의 수용은 퍼블릭 인터페이스의 관점에서 객체의 응집도가 낮아질 수 있다! (원칙의 함정)
- 객체의 내부 구조를 묻는 메시지가 아닌, 무언가를 시키는 메시지가 더 좋은 메시지

### 묻지 말고 시켜라

- 객체의 외부에서 해당 객체의 상태를 기반으로 결정을 내리는 것은 객체의 캡슐화를 위반한다.
- 객체지향의 기본은 함꼐 변경될 확률이 높은 정보와 행동을 하나의 단위로 통합하는 것.
- 묻지 말고 시켜라 원칙을 따르면 객체의 정보를 이용하는 행동을 객체의 외부가 아닌 내부에 위치. → 정보전문가에게 책임을 할당하게 되고, 높은 응집도를 가진 클래스가 됨.
- 상태를 묻는 오퍼레이션 → 행동을 요청하는 오퍼레이션으로 대체!

### 의도를 드러내는 인터페이스

- 메서드가 작업을 어떻게 수행하는지 나타내도록 메서드명을 짓는 것은 안 좋다.

    ```java
    public boolean isSatisfiedByPeriod()
    public boolean isSatisfiedBySequence()
    ```

    - 메서드에 대해 제대로 커뮤니케이션 하지 못한다.
    - 메서드 수준에서 캡슐화 위반
    - 책임이 아닌, 내부 구현을 먼저 구현한 메서드가 되는 거지.
- 그래서, '무엇을 하는지'를 드러내는 이름으로 메서드 작명

    ```java
    public boolean isSatisfiedBy()
    ```

    - 협력 안에서 수행해야 하는 책임에 관해 고민하고 작명
    - 즉, 클라이언트의 의도에 부합하도록 메서드 작명
    - 동일한 메서드명으로 클라이언트가 내부 구현에 대해 쉽게 추측
- 동일한 메서드 명이 동일한 메시지를 처리하도록, 인터페이스를 정의하는 것.
- 즉, 무엇을 하는지를 드러내는 이름으로 작명하면 하나의 타입 계층으로 묶기 쉬워진다.
- 의도를 드러내는 선택자 → 의도를 드러내는 인터페이스
- 매우 다른 두 가지 구현을 생각하고, 메서드 명을 정하자
- 오퍼레이션은 객체 자신이 아닌 클라이언트의 의도를 표현하는 이름을 가져야 한다.

### 함께 모으기

- Refactoring 과정.

## 3. 원칙의 함정

원칙은 절대적인 것이 아니며, 트레이드 오프를 잘 고려해야 한다.

### 디미터 법칙은 하나의 도트(.)를 강제하는 규칙이 아니다.

객체의 내부 구조를 노출시키지만 않으면 된다.

### 결합도와 응집도의 충돌

항상 '묻지말고 시켜라'가 정답은 아니다. 잘못된 책임이 전가되어 오히려 응집도는 낮아지고 결합도가 높아지는 결과를 초래할 때도 있다. 또한, 객체가 아닌 자료구조의 경우 내부 노출은 당연한 것이다(dto도 포함되는 것 같다).  트레이드오프를 항상 생각하고, 원칙을 맹신하지 말자. 물어야 할 떄는 묻자.

## 4. 명령-쿼리 분리 원칙

- 명령 : 프로시저. 상태를 변환시키지만 값을 리턴하지 않는다.
- 쿼리 : 함수. 값을 반환하는 대신 상태를 변화시키지 않는다.
- 명령-쿼리 인터페이스 : 명령과 쿼리를 분리한 인터페이스

### 반복 일정의 명령과 쿼리 분리하기

예시 들어 설명.

- 값을 반환하는 '쿼리'와 값을 반환하지 않는(void) '명령' 두 오퍼레이션을 명확히 구분
- 예측 가능하고 이해하기 쉬우며 디버깅이 용이한 동시에 유지보수가 수월해 짐.

### 명령-쿼리 분리와 참조 투명성

- 수학은 부수효과가 없기 때문에 불변성과 참조 투명성을 만족시킨다.
- 객채지향 패러다임은 객체의 상태 변경이라는 부수효과를 기반으로 하기 때문에 참조 투명성은 예외에 가깝다.
- 하지만 명령-쿼리 분리 원칙을 사용하면 제한적으로나마 참조 투명성의 장점을 누릴 수 있다.
- 함수형 프로그래밍이 각광받는 이유도 참조 투명성 때문이라고 한다.

### 책임에 초점을 맞춰라

- 책임주도 설계를 통해 앞에서 나온 법칙, 원칙을 쉽게 따를 수 있다.
- 중요한 것은 협력에 적합한 객체가 아닌 협력에 적합한 메시지이다.
- 메시지가 객체를 결정하게 하라.
- 시그니처는 단지 오퍼레이션의 이름과 인자, 반환값의 타입만 명시하므로, 오퍼레이션 호출조건이나 어떤 경우에 결과를 반환받을 수 없는지를 표현할 수 없다.
- 그래서 '계약에 의한 설계'를 통하여, 협력을 위해 클라이언트와 서버가 준수해야 하는 제약을 코드상에 명시적으로 표현하고 강제하게 하는 방법을 제시하는데, 이 내용은 부록A에 실려있다.

# 7장. 객체 분해

- 사람의 단기 기억과 장기 기억이 있다.
- 단기 기억은 5~9가지의 정보만 기억할 수 있다.
- 문제 해결에 필요한 정보가 단기 기억의 용량을 초과하는 순간, 인지 과부하가 일어난다.
- 이를 해결하기 위해, 불필요한 정보를 제거하고 현재의 문제 해결에 필요한 핵심만 남기는 '추상화'작업이 필요하다.
- 가장 일반적인 추상화는 '분해', 문제의 크기를 줄이는 것이다.
- 조지 밀러가 말하는 매직넘버(7+-2)에서의 각각의 정보는 가장 작은 단위의 정보를 뜻하는 것이 아니라, 논리적인 chunk(덩어리)를 말하는 것이다.
- chunk는 더 작은 chunk를 포함할 수 있으며, 연속적으로 분해가 가능하다.
- 즉, 한 번에 단기 기억에 담을 수 있는 추상화의 수에는 한계가 있지만, 추상화를 더 큰 규모의 추상화로 압축시킴으로써 단기 기억의 한계를 초월할 수 있다.
- 이는 소프트웨어 개발 분야에 있어 핵심적인 능력이다.

## 1. 프로시저 추상화와 데이터 추상화

- 프로그래밍 언어의 발전은 좀 더 효과적인 추상화를 이용해 복잡성을 극복하는 과정.
- 추상화의 발전 → 프로그래밍 패러다임의 탄생
- 프로그래밍 패러다임 = 프로그래밍을 구성하기 위해 사용하는 추상화의 종류 + 이 추상화를 이용해 소프트웨어를 분해하는 방법 두 가지 요소로 결정
- 즉, 프로그래밍 패러다임은 추상화와 분해의 관점에서 설명 가능

---

- 소프트웨어는 데이터를 이용해 정보 표현, 프로시저를 이용해 데이터 조작.
- 그리고, 현대의 중요한 프로그래밍 패러다임은 아래의 두 가지 추상화를 중심으로 시스템 분해 방법을 설명.
- 프로시저 추상화 : 소프트웨어가 무엇을 해야 하는지 추상화 하는 추상화 메커니즘
- 데이터 추상화 : 소프트웨어가 무엇을 알아야 하는지 추상화 하는 추상화 메커니즘

---

- 프로시저 추상화 = 기능 분해(functional decomposition) = 알고리즘 분해(algorithm decomposition)
- 데이터 추상화
    - 타입 추상화(type abstraction) = 추상 데이터 타입(Abstract Data type)
    - 데이터를 중심으로 프로시저 추상화(procedure abstraction) = 객체지향(Object-Oriented)
- '역할과 책임을 수행하는 객체' 가 바로 객체지향 패러다임이 이용하는 추상화이다.
- 즉, 기능을 '협력하는 공동체'를 구성하도록 객체들로 나누는 과정이 객체지향 패러다임에서의 분해 과정

---

- 프로그래밍 언어의 관점에서 객체지향이란 데이터를 중심으로 데이터 추상화와 프로시저 추상화를 통합한 객체를 이용해 시스템을 분해하는 것,
- 대부분 객체지향 언어는 이를 객체를 구현하기 위해 '클래스' 제공
- 즉, 프로그래밍 언어적인 관점에서 객체지향을 바라보는 일반적인 관점은, 데이터 추상화와 프로시저 추상화를 함께 포함한 클래스를 이용해 시스템을 분해하는 것.

---

- 이 장에서는 프로그래밍 패러다임의 발전 과정을 살펴 보며, 객체지향이 가지는 장점에 대해 느낄 것이다.

## 2. 프로시저 추상화와 기능 분해

### 메인 함수로서의 시스템

- 기능 분해(알고리즘 분해)는 가장 먼저 생겨난 프로그래밍 패러다임
- 추상화의 단위 : 프로시저
- 시스템은 프로시저를 단위로 분해
- 효과적인 정보 은닉 체계 구축에 한계를 가짐
- 예시는 전통적인 기능 분해 방법인 하향식 접근법
    - 시스템을 구성하는 가장 최상위 기능을 정의
    - 이 최상위 기능을 좀 더 작은 단계(더 구체적이며, 덜 추상적인)의 하위 기능으로 분해

### 급여 관리 시스템

기능 분해 방법은, 기능을 중심으로 데이터가 결정 됨.

하향식 기능 분해 방식은 유지 보수에 다양한 문제를 야기

### 급여 관리 시스템 구현

체계적이고 이상적인 방법은 불규칙하고 불완전한 인간과 만나 혼란과 동요를 야기한다.

### 하향식 기능 분해의 문제점

- 문제점
    - 시스템은 하나의 메인 함수로 구성돼 있지 않다.
    - 기능 추가나 요구사항 변경으로 인해 메인 함수를 빈번하게 수정해야 한다.
    - 비즈니스 로직이 사용자 인터페이스와 강하게 결합된다.
    - 하향식 분해는 너무 이른 시기에 함수들의 실행 순서를 고정시키기 때문에 유연성과 재사용성이 저하된다.
    - 데이터 형식이 변경될 경우 파급 효과를 예측할 수 없다.
- 설계는 변경에 대비하기 위한 것이며, 하향식 접근법과 기능 분해는 변경에 취약한 설계를 낳는다.

1. 하나의 메인 함수라는 비 현실적인 아이디어
    - 실제 시스템에 정상 이란 존재하지 않는다.
2. 메인 함수의 빈번한 재설계
    - 하나의 시스템은 하나의 메인 함수로 이루어져 있기 때문에, 기능 추가는 메인 함수의 재 설계로 이어질 수 밖에 없다.
3. 비즈니스 로직과 사용자 인터페이스의 결합
    - 관심사의 분리 실패
4. 성급하게 결정된 실행 순서
    - 설계 시작부터 시스템이 무엇을 해야 하는지가 아니라 어떻게 동작해야 하는지에 집중됨
    - 함수들의 실행 순서를 정의하는 '시간 제약'을 강조
    - 중앙집중 제어 스타일의 형태가 됨. (제어 흐름의 결정이 상위 함수에서 결정, 하위 함수는 적절한 시기에 호출만)
    - 제어 구조는 빈번한 변경의 대상이기 때문에, 문제된다.
    - 시간적인 제약을 버리고, 논리적인 제약을 설계의 기준으로 삼아야 된다.(호출 순서가 아닌 객체간의 논리적인 관계를 중심으로 설계를 하는, 객체지향 설계!)
    - 하위 함수는 상위 함수의 문맥 안에서 의미를 가지기 때문에, 재사용성이 떨어짐(일반적이지가 않다)
    - 즉, 결합도가 너무 높아서 문제!
        - 하위 함수는 상위 함수의 문맥에 강하게 결합
        - 함수는 절차를 이루는 다른 함수들과 시간적으로 강하게 결합
        - 전체 시스템의 핵심적인 구조를 결정하는 함수들이 데이터와 강하게 결합
5. 데이터 변경으로 인한 파급효과
    - 전역 데이터를 사용하기 때문에 어떤 데이터를 어떤 함수가 사용하고 있는지 추적하기 어렵다.
    - 즉, 데이터의 변경이 어떤 함수에 어떤 영향을 미칠지 예측하기 어렵다.
    - 데이터 변경으로 인한 영향을 최소화 하려면, 데이터와 함께 변경되는 부분과 그렇지 않은 부분을 명확하게 분리해야 한다. 이를 위해 데이터와 함께 변경되는 부분을 하나의 구현 단위로 묶고 외부에서는 제공되는 함수만 이용해 데이터에 접근해야 한다. 즉, 잘 정의된 퍼블릭 인터페이스를 통해 데이터에 대한 접근을 통제해야 하는 것이다.
    - 의존성 관리의 핵심 - 영향을 받는 부분과 받지않는 부분을 명확하게 분리하고, 잘 정의된 퍼블릭 인터페이스를 통해 변경되는 부분에 대한 접근을 통제
    - 기능 분해가 가진 본질적인 문제를 해결하기 위해, 위와 같은 개념으로 정보 은닉과 모듈 개념 제시됨.

### 언제 하향식 분해가 유용한가?

- 작은 프로그램과 개별 알고리즘 개발
- 프로그래밍 과정에서 이미 해결된 알고리즘을 문서화하고 서술
- 즉, 완성된 설계, 알고리즘을 서술하고 문서화 하는데는 용이, but 개발을 위한 설계에는 안 좋다.

## 3. 모듈

### 정보 은닉과 모듈

- 정보 은닉 = 함께 변경되는 부분을 하나의 구현 단위로 묶고, 퍼블릭 인터페이스를 통해서만 접근하도록 하는 것!(기능기반 x, 변경의 방향에 맞춰 시스템을 분해해야 함) = 시스템의 모듈 단위 분해를 위한 기본 원리
- 어려운 설계 결정 또는 변화할 것 같은 설계 결정의 목록을 사용하고, 은닉해야 한다. - 데비이드 파나스
- 모듈과 기능 분해는 상호 배타적 관계가 아니다 → 모듈 분해 후 기능 분해를 이용해 모듈의 퍼블릭 인터페이스 구현 가능
- 모듈이 감춰야 하는 두 가지 비밀
    - 복잡성 : 모듈을 추상화하여 단순한 인터페이스 제공
    - 변경 가능성 : 모듈 하나만 수정할 수 있도록
- 주로 데이터가 모듈의 일반적인 비밀이 된다.
- 데이터 캡슐화와 정보 은닉은 다른 개념! 정보은닉은 데이터 뿐 아니라 다른 모든것을 캡슐화 할 수 있다.
- 루비 - module // 자바 - 패키지 // C++(C#) - 네임스페이스  를 통해 모듈 구현 가능

### 모듈의 장점과 한계

- 장점
    - 모듈 내부의 변수가 변경되더라도 모듈 내부에만 영향을 미친다.
    - 비즈니스 로직과 사용자 인터페이스에 대한 관심사를 분리한다.
    - 전역 변수와 전역 함수를 제거함으로써 네임스페이스 오염(namespace pollution)을 방지한다 + 이름 충돌 완화
- 모듈은 변경 정도에 따라 시스템을 분해 - 높은 응집도
- 퍼블릭 인터페이스 제공 - 낮은 결합도
- 모듈은 데이터 중심(기능이 중심이 아니다!)의 시스템 분해 → 데이터와 함수가 통합된 한 차원 높은 추상화 제공
- 단점
    - 인스턴스 개념의 제공 x → 추상화 관점에서 한계점
    - just 정보의 덩어리 인 셈.
- 좀 더 높은 추상화를 위해서는 개별 직원을 독립적인 단위로 다룰 수 있어야 한다.

## 4. 데이터 추상화와 추상 데이터 타입

- 사용자 정의 타입을 추가
- 여러개의 인스턴스 생성
- 객체 기반 프로그래밍 언어 특징
    - 타입 정의를 선언할 수 있어야 한다.
    - 타입의 인스턴스를 다루기 위해 사용할 수 있는 오퍼레이션의 집합을 정의할 수 있어야 한다.
    - 제공된 오퍼레이션을 통해서만 조작할 수 있도록 데이터를 외부로부터 보호할 수 있어야 한다.
    - 타입에 대해 여러 개의 인스턴스를 생성할 수 있어야 한다.
- 모듈에 비해 좀 더 개념적으로 사람들의 사고방식에 가깝다. → 풍부한 추상화
- 단점
    - 아직 데이터와 기능을 분리해서 바라본다(main 함수에서 데이터 사용 로직 구현)

## 5. 클래스

### 클래스는 추상 데이터 타입인가?

[table : 추상 데이터 타입과 클래스의 차이](https://www.notion.so/3dd33fc0a403479abad85b662b0f998b?pvs=21)

- 추상 데이터 타입과 클래스는 동일하지 않다
- 가장 큰 차이는 다형성 지원 여부
- 타입 추상화 : 오퍼레이션 기준으로 타입 통합(추상화)
- 객체지향 : 타입 기준으로 오퍼레이션 통합(추상화)
- 객체지향에서 공통 로직 작성 : 부모클래스 작성
- 부모클래스 참조자에 대해 메시지 전송 → 실제 클래스에 따라 다른 절차 실행 ⇒ 동일한 메시지에 대해 서로 다르게 반응 = 다형성

### 변경을 기준으로 선택하라

- 클래스를 구현 단위로 사용한다는 것이 객체지향 프로그래밍을 한다는 것을 의미하지는 않는다.
- 타입을 기준으로 절차를 추상화하지 않았다면 객체지향 분해가 아니다.
- 클래스 내에 인스턴스 변수로 타입을 표현하면, 이는 객체지향의 위반
- 타입 변수를 이용한 조건문 대신 다형성으로 대체 → 변경과 확장에 용이해진다(타입 추가를 위해 클라이언트의 코드를 수정할 필요 없이, 상속받는 클래스를 구현하기만 하면 된다)
- 개방-폐쇄 원칙 : 기존 코드에 아무런 영향 없이 새로운 객체 유형과 행위를 추가할 수 있는 객체지향의 특성
- 트레이드 오프를 생각하라! 추상 데이터 타입과 객체지향, 각각의 장단점이 있다.
    - 타입 추가라는 변경의 압력이 더 강한 경우 : 객체지향
    - 오퍼레이션 추가가 더 강한 경우 : 추상 데이터 타입
- 추상 데이터 타입의 접근법을 객체지향 설계에 구현한 것 → 데이터 주도 설계 → 개선된 것이 책임 주도 설계(워프스브록)
- 모듈과 추상 데이터 타입이 뎅터 중심적인 관점 ↔ 객체지향은 서비스 중심적인 관점 - 타모시 버드

### 협력이 중요하다

- 잊지 말자 - 객체지향의 본질은 역할, 책임, 협력
- 타입 계층과 다형성, 절차 추상화는 책임 수행의 방법일 뿐

# 8. 의존성 관리하기

- 협력은 의존성을 낳는다.
- 과도한 협력은 설계를 곤경에 빠트릴 수 있다.
- 객체지향 설계란 의존성을 관리하는 것이다.

## 1. 의존성 이해하기

### 변경과 의존성

- 어떤 객체가 다른 객체를 필요로 할 때, 두 객체 사이에 의존성이 생김
- 의존성은 실행시점과 구현시점에 다른 의미를 가진다
    - 실행 시점 : 의존하는 객체가 정상적으로 동작하기 위해서는 실행시에 의존 대상 객체가 반드시 존재해야 한다.
    - 구현 시점 : 의존 대상 객체가 변경될 경우 의존하는 개체도 함께 변경된다.
- 의존성은 두 요소 사이의 의존성은 의존되는 요소가 변경될 때 의존하는 요소도 함께 변경될 수 있다는 것을 의미 (변경에 의한 영향의 전파 가능성 암시)
- 즉 의존성은, 의존하고 있는 대상의 변경에 영향을 받을 수 있는 가능성

### 의존성 전이

- 의존성은 전이됨
  A - (A의)직접의존성 - B - (A의)간접의존성 - C
- 의존성은 함께 변경될 수 있는 가능성을 의미하기 때문에 모든 경우에 의존성이 전이되는 것은 아니다.
    - 변경의 방향과 캡슐화의 정도에 따라 다름
- 직접 의존성 / 간접 의존성
    - 간접 의존성 : 의존성 전이에 의해 영향이 전파되는 경우.
- 클래스가 아니더라도 변경과 관련이 있는 모든 것에 의존성이라는 개념을 적용할 수 있다.

### 런타임 의존성과 컴파일타임 의존성

- 런타임 / 컴파일타임
    - 컴파일타임은 컴파일하는 시점 또는 코드 그자체를 가리킬 수도 있다.
- 런타임 의존성과 컴파일타임 의존성은 다를 수 있으며, 다를수록 유연하고 재사용 가능한 코드라고 할 수 있다.
    - 컴파일 타임에는 추상화된 클래스에 대한 의존성을 가져야 하며
    - 실제로 협력할 객체에 대한 의존성은 런타임에 해결해야 한다.

### 컨텍스트 독립성

- 클래스가 특정한 문맥에 강하게 결합될수록 다른 문맥에서 사용하기는 더 어려워진다. 클래스가 사용될 특정한 문맥에 대해 최소한의 가정만으로 이뤄져 있다면 다른 문맥에서 재사용하기가 더 수월해진다.
    - 이를 컨텍스트 독립성이라고 부른다.
- 컨텍스트에 대한 정보가 적을수록 다양한 컨텍스트에서 재사용될 수 있다.

### 의존성 해결하기

- 의존성 해결 : 컴파일타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체하는 것
- 의존성 해결의 세 가지 방법
    - 객체를 생성하는 시점에 생성자를 통해 의존성 해결
    - 객체 생성 후 setter 메서드를 통해 의존성 해결
    - 메서드 실행 시 인자를 이용해 의존성 해결
- setter를 사용하면 좀 더 유연해짐
- setter만 사용하기보다는, 생성자와 setter를 같이 사용하면 좋다.
- 특정 메서드에서만 사용되거나, 의존 대상이 매번 바뀌는 경우 메서드 인자로 의존성 해결

## 2. 유연한 설계

의존성 관리에 유용한 몇 가지 원칙과 기법을 설명

### 의존성과 결합도

- 의존성이 나쁜게 아니다. 과한 의존성이 나쁜 것이다.
- 바람직한 의존성이란, 재사용성이 좋은 것.
    - 바람직한 의존성 : 컨텍스트 독립적인 의존성 / 낮은 결합도
    - 바람직하지 못한 의존성 : 특정 컨텍스트에 강하게 결합된 의존성 / 높은 결합도
- 재사용을 위해 내부 구현을 변경하게 하는 의존성은 바람직하지 않은 의존성
- 즉, 특정 클래스에 대해 의존성을 갖게 하지 말고 추상화해서 의존성을 부여해라!

### 지식이 결합을 낳는다.

- 정보를 적게 알아야 한다.
- 불필요한 정보를 감추기 위해 추상화 사용

### 추상화에 의존하라

- 추상화란 어떤 양상, 세부사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법이다.
- 추상화는 불필요한 정보를 감춤 -> 알아야 할 지식의 양을 줄여줌
- 지식의 양 : 구체 클래스 의존성 > 추상 클래스 의존성 > 인터페이스 의존성

### 명시적인 의존성

- 인스턴스 변수의 타입을 추상클래스나 인터페이스로 선언하는 것만으로는 부족하다.
    - new를 통해 구체 클래스를 생성하는 경우가 문제.
    - 클래스 내부의 구체 클래스에 대한 모든 의존성을 제거해야 한다!
- 생성자, setter 메서드, 메서드 인자를 사용해 의존성을 해결하자
    - 이는 의존 사실을 퍼블릭 인터페이스에 노출 시키는 것이다.
- 명시적인 의존성 / 숨겨진 의존성
    - 숨겨진 의존성은 숨겨진 것만으로 문제가 되며, 더욱이 다른 컨텍스트 재사용을 위해 내부 구현을 바꿔야 하는 문제점이 있다.
    - 퍼블릭 인터페이스에 의존 사실을 노출시켜야 한다. 그럼으로 실행 컨텍스트에 적절한 의존성을 선택할 수 있다.
    - 즉 의존성을 명시적으로 드러내야 한다.

ps. Laravel은 provider에서 런타임 의존성을 관리해주는거구나. 최대한 코드 내에는 new 메서드를 피하고, provider 내에서 new를 써주자.

### new는 해롭다

- new 연산자는 결합도를 극단적으로 높인다.
- 의존성을 주는 객체의 필요한 특정 성질(필드, 메서드) 빼고는 다 몰라야 한다.
- 즉, 직접 생성하지 말고 앞에서 설명한 세 가지 의존성 해결 방법을 사용한다.
- 객체를 생성하는 책임은 객체 내부가 아닌 클라이언트로 옮긴다.
- 사용과 생성의 책임을 분리하고, 의존성을 생성자에 명시적으로 드러내고, 구체클래스가 아닌 추상클래스에 의존하자

### 가끔은 생성해도 무방하다

- 결합도와 사용성의 트레이드오프를 생각하자
- 책에서는 생성자/메서드를 오버로딩 후 체이닝 하는 방법이 좋다고 설명하고 있다.
- 또한, 9장의 FACTORY 방법을 사용할 수도 있다.

### 표준 클래스에 대한 의존은 해롭지 않다.

- 바뀔 확률이 0에 수렴하기 때문
- 그런 표준 클래스도, 추상화에 의존하고 의존성을 명시적으로 드러내는 것은 좋은 설계습관이다.

### 컨텍스트 확장하기

- 코드를 수정하지 말고, 새로운 구현 객체를 추가함으로써 쉽게 컨텍스트를 확장할 수 있었다.

### 조합 가능한 행동

- 중요한 파트라고 본다. 여기는 책을 다시 보는게 좋겠다.
- 객체의 재조합으로 시스템의 작동방식 변경
- 클래스는 how가 아닌 what을 표현 -> 선언적으로 객체의 행동 정의
- 이런 설계의 핵심은 의존성을 관리하는 것.

## 정리

해야할 것은 다음과 같다.

- 추상 타입 의존
- 명시적으로 의존성 관리
- 객체의 생성과 역할 수행 분리
- 객체의 재조합으로 컨텍스트 확장(시스템의 새로운 기능 구현)

# 9. 유연한 설계

8장의 의존성 관리 기법을 정리하여 원칙으로 설명

## 1. 개방-폐쇄 원칙

- 소프트웨어 개체(클래스, 모듈, 함수)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.
    - 확장 : 동작의 추가
    - 수정 : 코드의 수정

### 컴파일타임 의존성을 고정시키고 런타임 의존성을 변경하라

- 코드의 수정 없이 기능이 추가될 수 있어야 한다
  = 컴파일 의존성은 변하지 않으면서 런타임 의존성은 변경될 수 있어야 한다.

### 추상화가 핵심이다

- 개방-폐쇄 원칙의 핵심은 추상화에 의존하는 것.
- 추상화가 개방-폐쇄 원칙을 가능하게 만드는 이유
    - 수정에 대하여 닫혀있다 : 추상화 부분은 공통적인 부분이므로 코드로 구현되어있다. 그리고 문맥이 바뀌더라도 변하지 않아야 하므로 수정할 필요가 없
    - 다.
    - 확장에 대하여 열려있다 : 추상화를 통해 생략된 부분은 확장의 여지를 남긴다
- 추상화를 했다고 모든 수정에 대해 설계과 폐쇄되는 것은 아니다.
    - 변하는 것과 변하지 않는 것이 무엇인지를 이해하고, 이를 추상화의 목적으로 삼아야 한다.


## 2. 생성 사용 분리

- 동일한 클래스에서 특정 객체를 '생성'하면서 동시에 '사용'하면 문제가 된다
    - 이질적인 두 가지 목적을 가진 코드가 공존하기 때문!
- 그러므로 객체의 생성과 사용을 분리해야 한다.
- 생성은 client에서 하는 것이 맞다. client가 프로그램의 컨텍스트를 결정하는 것이 자연스럽기 떄문! 서버 객체는 컨텍스트에서 자유로워야 한다.

### Factory 추가하기

- client마저 컨텍스트에 묶이지 않기를 바란다면(생성을 분리하고 싶다면) Factory 객체를 만들어 사용하자!
    - Factory 객체는 객체 생성에 특화된 객체이다.

### 순수한 가공물에게 책임 할당하기

- 도메인 모델에서 적절한 책임을 부여할만한 Information expert가 없거나, 책임 부여 시 응집도 또는 결합도 등의 문제가 생길 경우, Pure fabrication 패턴을 고려하라.
- Pure fabrication : 순수한 가공물
    - 도메인과 무관한 인공적인 객체 (Ex. Factory 객체)
- 표현적 분해와 행위적 분해
    - 표현적 분해 : 도메인을 표현하는 객체로 시스템 분해
    - 행위적 분해 : 도메인과 무관한 객체로 시스템 분해(Pure fabrication 패턴이 여기에 해당함)
- 반드시 도메인 객체로만 시스템을 채울 필요는 없다.

### 의존성 주입

- 외부에서 다른 객체에 의해 객체를 전달받음으로써 의존성을 해결하는 방법
    - 정확하게는, 의존성을 해결하기 위해 의존성을 객체의 퍼블릭 인터페이스에 명시적으로 드러내서, 외부에서 필요한 런타임 의존성을 전달할 수 있도록 만드는 방법
- 생성자 주입 / setter 주입 / 메서드 주입
- 각각 장/단점이 있다.
    - 생성자 주입 : 런타임때 바꾸지 못하지만 안정적
    - setter 주입 : 런타임때 바뀔 수 있지만 명시적으로 표현할 수 없음
    - 메서드 주입 : 특정 메서드에서만 사용될 때

### 숨겨진 의존성은 나쁘다

- Service Locator : 의존성을 해결할 객체들을 보관하는 저장소 객체
- 깊은 호출 계층에 걸쳐 동일한 객체를 계속해서 전달해야 하는 문제 등이 있을 때 고려
- 하지만, Service Locator 패턴은 문제가 있다.
    1. 의존성을 감춘다
    2. 테스트 케이스를 짜기 힘들다(전역변수를 사용하기 때문)
- 핵심은, 의존성을 객체의 퍼블릭 인터페이스에 노출시키는 것이 좋다.

** 숨겨진 의존성이 문제되는 이유

1. 캡슐화를 위반한다.
    - 이유는? : 코드의 내부 구현을 이해할 것을 강요하기 때문. 퍼블릭 인터페이스만으로 사용 방법을 이해할 수 있는 코드가 캡슐화의 관점에서 훌륭한 코드이다. 단순히 변수를 private으로 숨긴다고 될 일이 아니다.
2. 의존성의 대상을 설정하는 시점과 의존성이 해결되는 시점을 멀리 떨어뜨려 놓는다.
3. 문제가 컴파일타임이 아닌 런타임에 가서 발견되기 때문에 이해하기 어렵고 디버깅하기 어렵다.

## 4. 의존성 역전 원칙

- 의존성 역전 원칙
    1. 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안 된다. 둘 모두 추상화에 의존해야 한다.
    2. 추상화는 구체적인 사항에 의존해서는 안 된다. 구체적인 사항은 추상화에 의존해야 한다.
- 기존의 상위 → 하위 의존성 관계에서 하위, 상위 → 추상화 의 관계로 바뀌었기 때문에, 의존성 역전 원칙이라 표현한다.

### 의존성 역전 원칙과 패키지

- 객체지향 프로그래밍 언어에서 어떤 구성 요소의 소유권을 결정하는 것은 모듈이다
    - 자바 : 패키지
    - C#, C++ : 네임스페이스
- SEPERATED INTERFACE 패턴
    - 추상화를 클라이언트가 속한 패키지에 포함 시키고, 재사용 될 필요가 없는 구현 클래스는 별도의 독립적인 패키지에 모아야 한다.
    - 불필요한 재 컴파일 및 재배포로 인한 빌드 시간의 증가를 막기 위함!

!https://s3-us-west-2.amazonaws.com/secure.notion-static.com/62ecec06-b784-4cd3-bb6b-6dafa7701026/Untitled.png

!https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a812dabf-8af8-4a56-8e10-8ce990c430ea/Untitled.png

## 5. 유연성에 대한 조언

### 유연한 설계는 유연성이 필요할 때만 옳다

- 유연한 코드는 복잡하다.
- 변경이 일어나지 않을 코드를 유연하게 만들 필요가 없다.
- 변경은 예상이 아니라 현실이어야 한다.

### 협력과 책임이 중요하다.

- 역할, 책임, 협력에 먼저 집중하라
- 책임을 먼저 할당하고, 협력의 균형을 맞춘 뒤 객체 생성은 맨 마지막에 고려하라.

## 자체 정리

- 추상화에 의존시키자
- 객체의 생성과 사용은 분리하자
    - 이 때 Factory 등의 pure fabrication을 활용하자
- 의존성 주입은 퍼블릭 인터페이스에 노출시키자.
- 패키지 정리 시 구현 클래스 따로, 인터페이스와 클라이언트 클래스 따로!
- 유연성은 필요할 때만 고려하자!
- 로그 같은 정보는 전역변수로 사용하는게 좋겠다.

# 10. 상속과 코드 재사용

코드 재사용의 관점에서 '상속'을 살펴볼 것이다.

## 1. 상속과 중복 코드

중복을 피해야 하는 이유 - 중복 코드는 나쁘다

### DRY 원칙

- 중복 코드는 변경을 방해한다.
- 중복 = 요구사항이 변경됐을 때 두 코드를 함께 수정해야 할 때.
    - 코드의 모양이 비슷하다고 다 중복은 아니다!
- DRY = Don't Repeat Yourself
  모든 지식은 시스템 내에서 단일하고, 애매하지 않고, 정말로 믿을 만한 표현양식을 가져야 한다.
    - 한 번, 단 한번(Once and Only Once)
    - 단일 지점 제어(Single Point Control) 원칙

### 중복과 변경

- 구현 시간을 절약한 대가는 더 클 수 있다.
- 중복 코드는 새로운 중복 코드를 부른다.
- 그리고, 실수할 여지를 더욱 많이 남기게 된다.

### 상속을 이용하여 중복 코드 제거하기

이미 존재하는 클래스와 유사한 클래스가 필요하다면, 상속을 고려하라.

- 하지만 상속을 염두하지 않고 설계된 클래스를 상속을 이용해 재사용하기는 어렵다.
    - 자식 클래스 작성자가 부모 클래스에 대한 정확한 이해도를 가져야 한다. 즉, 결합도를 높힌다.
    - 그리고, 부모 클래스와 자식 클래스의 결합도는 코드 수정을 어렵게 한다.

### 강하게 결합된 Phone과 NightlyDiscountPhone

- 세금을 부과하는 로직이 중복 됨 → 상속을 사용했음에도 새로운 중복코드 발생
- ***상속을 위한 경고 1***   
  자식 클래스의 메서드 안에서 super 참조를 이용해 부모 클래스의 메서드를 직접 호출할 경우 두 클래스는 강하게 결합된다. super 호출을 제거할 수 있는 방법을 찾아 결합도를 제거하라.
- 자식 클래스와 부모 클래스가 강하게 결합한 경우, 자식 클래스가 부모 클래스의 변경에 취약해지는 현상이 발생함 ⇒ 취약한 기반 클래스 문제 (코드 재사용을 목적으로 상속할 때 발생하는 대표적인 문제)

## 2. 취약한 기반 클래스 문제

- 부모 클래스의 변경에 의해 자식 클래스가 영향을 받는 현상
    - 상속을 사용할 경우 피할 수 없는 객체지향 프로그래밍의 근본적인 취약성
- 상속은 자식 클래스가 부모 클래스의 구현 세부사항에 의존하도록 만들기 떄문에 캡슐화를 약화시킨다.

### 불필요한 인터페이스 상속 문제

- ***상속을 위한 경고 2***   
  상속받은 부모 클래스의 메서드가 자식 클래스의 내부 구조에 대한 규칙을 깨트릴 수 있다.

### 메서드 오버라이딩의 오작용 문제

- ***상속을 위한 경고 3***   
  자식 클래스가 부모 클래스의 메서드를 오버라이딩 할 경우 부모 클래스가 자신의 메서드를 사용하는 방법에 자식 클래스가 결합될 수 있다.
- 클래스가 상속되기를 원한다면, 상속을 위해 클래스를 설계하고 문서화 해야 한다. - 조슈아 블로치
    - 하지만, 이 또한 문제가 있으니, 문서 자체도 캡슐화를 위반하는 행위이다.
    - 즉, 상속은 캡슐화를 희생할 수 밖에 없다. (트레이드오프 문제)

### 부모 클래스와 자식 클래스의 동시 수정 문제

- ***상속을 위한 경고 4***   
  클래스를 상속하면 결합도로 인해 자식 클래스와 부모 클래스의 구현을 영원히 변경하지 않거나, 자식 클래스와 부모 클래스를 동시에 변경하거나 둘 중 하나를 선택할 수밖에 없다.
    - 또한 수정을 위해서 작업자가 부모 클래스를 속속이 알고 있어야 한다.

## 3. Phone 다시 살펴보기

상속으로 인한 피해를 최소화할 수 있는 방법

### 추상화에 의존하자

- 부모 클래스와 자식 클래스 모두 추상화에 의존하도록
- 코드 중복을 제거하기 위한 상속을 도입할 때의 두 가지 원칙
    - 두 메서드가 유사하게 보인다면 차이점을 메서드로 추출하라. 메서드 추출을 통해 두 메서드를 동일한 형태로 보이도록 만들 수 있다.
    - 부모 클래스의 코드를 하위로 내리지 말고 자식 클래스의 코드를 상위로 올려라. 부모 클래스의 구체적인 메서드를 자식 클래스로 내리는 것보다 자식 클래스의 추상적인 메서드를 부모 클래스로 올리는 것이 재사용성과 응집도 측면에서 더 뛰어난 결과를 얻을 수 있다.

### 차이를 메서드로 추출하라

변하는 것으로부터 변하지 않는 것을 분리하라 / 변하는 부분을 찾고 이를 캡슐화하라

### 중복 코드를 부모 클래스로 올려라

- 올릴 때, 메서드를 먼저 옮기면 인스턴스 변수를 옮기는 건 쉽다.
- 오버라이딩 하는 메서드를 한 번 더 메서드로 분리한 후, 그 메서드는 추상 클래스로 옮기고 부모클래스와 자식클래스가 그 추상클래스를 상속받도록 한다.

!https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3bc49a6c-dd72-4962-baf9-d120fc206cd4/Untitled.png

### 추상화가 핵심이다

- 위와 같이 나누면, 각각의 클래스가 하나의 변경 이유만을 가진다(단일 책임 원칙을 준수한다).
- 즉, 직접 상속하지 말고 추상클래스를 같이 상속받게 하자.
    - 이는 구현에 의존하지 말고 추상화에 의존해야 한다는 원칙과 같다.(9장?)

### 의도를 드러내는 이름 선택하기

### 세금 추가하기

- 메서드 구현에 대한 결합은 추상 메서드를 추가함으로써 어느 정도 완화가 가능하지만, 인스턴스 변수에 대한 결합은 피할 수 없다.
    - 하지만, 객체 생성 로직의 변경에 유연하게 대응할 수 있는 다양한 방법이 존재한다.
    - 따라서 객체 생성 로직에 대한 변경을 막기보다는 핵심 로직의 중복을 막자.

## 4. 차이에 의한 프로그래밍

기존 코드와 다른 부분만을 추가함으로써 에플리케이션의 기능을 확장하는 방법
중복 코드의 제거, 코드 재사용을 위함

- 상속을 통해 차이에 의한 프로그래밍을 쉽게 실현할 수 있지만
- 상속은 그렇게 좋은 방법이 아니다. 합성을 고려하자.

## 개인 정리

- 상속은 어쩔수없이 캡슐화를 위반하게 한다. 왠만하면 쓰지 말자
- 그래도 쓰는게 좋을 것 같은 경우, 추상클래스를 두고 그 추상클래스를 코드가 중복되는 클래스가 동시에 상속받도록 하자.

# 11. 합성과 유연한 설계

둘 다 코드를 재사용 하는 데 이용된다는 점 빼고는 차이가 크다.

[상속과 합성](https://www.notion.so/05845a50fcba43aeae4287a09019d09d?pvs=21)

## 1. 상속을 합성으로 변경하기

합성이 제공하는 이점 1)'안정성' 에 대해 예시를 통해 확인

- 포워딩 / 포워딩 메서드 → 기존 클래스의 인터페이스를 그대로 제공하면서, 구현의 결합 없이 일부 작동 방식을 변경
- 몽키 패치?

## 2. 상속으로 인한 조합의 폭발적인 증가

합성이 제공하는 유연성에 대한 설명하기 전, 상속이 얼마나 유연하지 못한가에 대해 예시로 설명



- 상속으로 인해 결합도가 높아지면, 코드 작업량이 과도하게 늘어날 수 있다.
- 컴파일타임에 결정 된 자식 클래스와 부모 클래스의 관계는 변경될 수 없기 때문에, 다양한 조합을 구현하기 위해 조합의 수 만큼 클래스를 추가해야 한다.
- 작은 기능을 조합해 더 큰 기능을 수행하는 객체를 만들려면...
    - 하나의기능을 추가하거나 수정하기 위해 불필요하게 많은 수의 클래스를 추가하거나 수정해야 한다. → 클래스 폭발 문제 또는 조합의 폭발 문제
    - 단일 상속만 지원하는 언어에서는 상속으로 인해 오히려 중복 코드의 양이 늘어날 수 있다.
- 추상 메서드와 훅 메서드
    - 자식 클래스에서 부모 클래스의 메서드를 보완하려 할 때, 개방-폐쇄 원칙을 만족하기 위해 추상 메서드를 사용한다.
    - 보완해야 할 부모클래스의 메서드에서 추상 메서드 호출하고, 자식 클래스에서 추상 메서드 오버라이딩하는 방식.
    - 이 때 대부분의 자식 클래스가 추상 메서드에 대해 동일한 로직을 가지고 있을 때, 해당 추상 메서드에 default 로직을 구현하는 '훅 메서드'로 만들면 좋다.


## 3. 합성 관계로 변경하기

합성이 제공하는 이점 2)'유연성' 에 대해 설명

- 합성은 컴파일 타임 관계를 런타임 관계로 바꿈으로써, 클래스 폭발 문제를 해결한다.
    - 구현이 아닌 퍼블릭 인터페이스에 대해서만 의존할 수 있기 때문에, 런타임에 객체의 관계를 변경할 수 있음.

- 각 정책을 하나의 인터페이스를 구현하는 개별 클래스로 만든 뒤, 조합을 통해 요금을 계산
- 상속은 구현 상속과 인터페이스 상속으로 나뉜다.
    - 이 장에서 살펴 본 상속의 단점은 구현 상속에 국한되며, 인터페이스 상속은 13장에서 배울 것이다.
    - 구현 상속은 피하고 인터페이스 상속을 사용해야 한다.


## 4. 믹스인

- 상속과 클래스를 기반으로 하는 재사용 방법을 사용하면 클래스의 확장과 수정을 일관성 있게 표현할 수 있는 추상화의 부족으로 인해 변경하기 어려운 코드를 얻게 된다. 따라서 구체적인 코드를 재사용하면서도 낮은 결합도를 유지할 수 있는 유일한 방법은 재사용에 적합한 추상화를 도입하는 것이다.
- 믹스인 : 객체를 생성할 떄 코드 일부를 클래스 안에 섞어 넣어 재사용하는 기법
    - 컴파일 시점에 필요한 코드 조각을 조합하는 재사용 방법
    - 코드를 다른 코드 안에 섞어 넣는다.
    - 합성처럼 유연하면서도 상속처럼 쉽게 코드를 재사용 할 수 있다.
    - '추상 서브클래스'라고도 불리며, '쌓을 수 있는 변경'이라는 특징을 가진다.
- 언어에서 지원하거나, 다른 용도로 고안된 요소를 이용해 믹스인을 구현하기도 한다.
- 예시는 scala의 trait

---

논의 거리 :

1. 몽키패치?
2. 자바에서 믹스인 구현 되나요? / 믹스인 써보셨나요?

# 12장. 다형성

- 상속의 목적은...
    - 코드재사용 x, 타입 계층 구조화 o
- 상속을 통해 타입 계층을 구조화하여 다형성 구현의 기반 마련
- 이번 장에서는...
    - 상속의 관점에서 다형성이 구현되는 기술적인 메커니즘 설명

## 12.1 다형성

- 다형성 : 여러 타입을 대상으로 동작할 수 있는 코드를 작성할 수 있는 방법
- 객체지향 프로그래밍에서의 다형성의 분류
    - 오버로딩 : 오버로딩
    - 강제 다형성 : 동일한 연산자를 다양한 타입에 사용할 수 있는 방식
    - 매개변수 다형성 : 클래스의 인스턴스 변수 또는 메서드의 매개변수 타입을 임의의 타입으로 선언한 후, 사용하는 시점에 구체적인 타입으로 지정하는 방식 (제네릭 프로그래밍)
    - 포함 다형성 (서브타입 다형성) : 메시지가 동일하더라도, 수신한 객체의 타입에 따라 행동이 달라지는 능력

!https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1a72ab5f-92c6-457a-aa26-8bcaf5842a12/Untitled.png

- 포함 다형성이 가장 일반적으로 통용되는 다형성. 이번 장에서는 포함 다형성에 대해 설명.
- 포함 다형성을 구현하는 가장 일반적인 방법이 '상속'
- 상속은, 클래스들을 게층으로 쌓아 올린 후 상황에 따라 적절한 메서드를 선택할 수 있는 메커니즘을 제공 → 포함 다형성을 위해 상속을 사용하는 이유
    - 실행 메서드의 선택 기준은 어떤 메시지를 수신했는지에 따라, 어떤 클래스의 인스턴스인지에 따라, 상속 계층이 어떻게 구성되어 있는지에 따라 달라진다.
- 이번 장의 내용은, 상속 외에도 포함 다형성을 구현할 수 있는 다양한 방법에 공통적으로 적용할 수 있는 개념임!!!

## 12.2 상속의 양면성

상속의 메커니즘 → 타입 계층을 기반으로 한 다형성의 동작 방식을 이해하는 데 필요한 개념 설명

- 업캐스팅
- 동적 메서드 탐색
- 동적 바인딩
- self 참조
- super 참조

### 상속을 사용한 강의 평가

예제 코드 제시

- 메서드 오버라이딩 : 자식 클래스 안에 상속받은 메서드와 동일한 시그니처의 메서드를 재정의해서 부모 클래스의 구현을 새로운 구현으로 대체하는 것
- 메서드 오버로딩 : 부모 클래스에서 정의한 메서드와 이름은 동일하지만 시그니처는 다른 메서드를 자식 클래스에 추가하는 것

### 데이터 관점의 상속

!https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a539e80e-71d8-4c90-a631-ec9354e156b8/Untitled.png

- 데이터 관점에서의 상속 : 자식 클래스가 부모 클래스의 인스턴스를 포함

### 행동 관점의 상속

- 행동 관점에서의 상속 : 부모 클래스가 정의한 일부 메서드를 자식 클래스의 메서드로 포함
- 메서드의 경우 인스턴스들이 하나의 클래스를 공유함(포인터를 가짐)

!https://s3-us-west-2.amazonaws.com/secure.notion-static.com/048cf883-9961-41c7-8c9e-13c41c40b649/Untitled.png

- 메시지를 수신하면, 객체는 class포인터로 연결된 자신의 클래스에서 적절한 메서드가 존재하는지 확인한 뒤, 없으면 parent 포인터를 따라 부모 클래스를 차례로 훑는다.

!https://s3-us-west-2.amazonaws.com/secure.notion-static.com/65156ff8-1a0d-4160-b2d7-c4265e0a3ab0/Untitled.png

ps. 위 그림은 개념을 단순화한 그림일 뿐, 구체적인 구현 방법이나 메모리 구조는 언어나 플랫폼에 따라 다름!

## 12.3 업캐스팅과 동적 바인딩

- 업캐스팅 : 부모 클래스 타입으로 자식 인스턴스 할당
- 동적 바인딩 : 선언된 타입이 아닌 실제 바인딩 된 객체 타입에 따라 실행되는 메서드가 결정 (런타임 결정)

## 12.4 동적 메서드 탐색과 다형성

- 객체지향 시스템에서의 메서드 선택 과정
    1. 메시지를 수신한 객체는 먼저 자신을 생성한 클래스에 적합한 메서드가 존재하는지 검사, 존재하면 메서드를 실행하고 탐색을 종료.
    2. 메서드를 찾지 못했다면 부모 클래스에서 메서드 탐색을 계속. 이 과정은 적합한 메서드를 찾을 때까지 상속 계층을 따라 올라가며 계속된다.
    3. 상속 계층의 가장 최상위 클래스에 이르렀지만 메서드를 발견하지 못한 경우 예외를 발생시키며 탐색을 중단한다.

!https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f6484b44-75da-4e28-8f79-8ea48891564a/Untitled.png

- self 참조 : 객체가 메시지를 수신하면 컴파일러는 self 참조라는 임시 변수를 자동으로 생성해서, 메시지를 수신한 객체를 가리키도록 설정한다.
- 즉 시스템은 class 포인터, parent 포인터, self 참조를 조합해서 메서드를 탐색
- 동적 메서드 탐색의 두 가지 원리
    - 자동적인 메시지 위임 : 자식→부모클래스로 처리 위임
    - 동적인 문맥 : 실제로 어떤 메서드를 실행할지는 실행 시점에 결정되며, 메서드를 탐색하는 경로는 self 참조를 이용해서 결정한다.


### 자동적인 메시지 위임

- 상속 계층 정의 = 메서드 탐색 경로 정의
- 상속 외의 메시지 자동 위임 메커니즘
    - 루비 - 모듈
    - 스몰토크, 스칼라 - 트레이트
    - 스위프트 - 프로토콜, 확장
- 메서드 오버라이딩 :
    - 자식과 부모가 동일한 시그니처의 메서드
    - 부모의 메서드를 감춘다.
- 메서드 오버로딩 :
    - 자식과 부모의 메서드가 이름은 동일하지만 시그니처가 완전히 동일하지 않다.
    - 시그니처가 다르기에 자식과 부모의 메서드가 공존
- 이름 숨기기 :
  일부 언어에서는 상속계층 간의 메서드 오버로딩을 지원하지 않기 때문에, 동일한 클래스 내에서 같은 이름의 메서드를 정의하는 것 만이 메서드 오버로딩이라 생각하는 경향이 있다.

### 동적인 문맥

- 동적인 문맥을 결정하는 것은 메시지를 수신한 객체를 가리키는 self 참조다.
- self 전송은 상속계층과 합쳐져 이해하기 어려운 코드를 낳을 때도 있다.
    - 특정 클래스에서 자신의 메서드를 호출한다 해도, 현재 클래스부터 메서드 탐색을 시작하는 것이 아니라 현재 객체, 즉 self 참조부터 다시 메서드를 탐색하기 때문!


### 이해할 수 없는 메시지

- 정적 타입 언어 : 컴파일 시점에서 에러 발생. 덜 유연하지만 안정적.
- 동적 타입 언어 : 실행 단계에서 에러 발생. 유연함. 도메인-특화 언어 개발에 적합(메타 프로그래밍 영역, 동적 리셉션)

업캐스팅, 동적 바인딩이라는 언어적인 특성과 실행 시점에 적절한 메서드를 선택하는 동적 메서드 탐색 등의 메커니즘이 동일한 메시지에 대해 서로 다른 메서드를 실행할 수 있는 다형성을 구현할 수 있게 만든다.

### self 대 super

- super 전송
    - 부모 클래스로 메시지 전송 → 없으면 다시 부모클래스로 재 전송
    - 반드시 호출한 클래스의 부모 클래스로 호출되기 때문에, 컴파일 시점에 결정된다.

## 12.5 상속 대 위임

### 위임과 self 참조

- 위임과 포워딩
    - 위임은 자신이 수신한 메시지를 다른 객체에게 동일하게 전달해서 처리를 요청하는 것. 이 때 self참조를 함께 보낸다.
    - 포워딩 : 메시지 전송이 아닌 단순한 코드 재사용. self참조를 보내지 않는다.
- 위임을 통해 자식클래스와 부모클래스 인스턴스 끼리 동일한 실행 문맥을 공유
- 상속관계 끼리는 자동적인 메시지 위임이 일어난다.

### 프로토타입 기반의 객체지향 언어

프로토타입 객체지향 언어는 클래스가 없이 객체만 있기 때문에, 상속이 따로 없다.

상속을 구현하는 유일한 방법은 객체 사이의 위임을 이용하는 것(자바스크립트는 prototype으로 연결된 객체들의 체인을 거슬러 올라가며 자동적으로 메시지에 대한 위임을 처리).

이를 통해 알 수 있는것은,

1. 객체지향은 객체지를 지향하는 것일 뿐, 클래스가 없어도 된다.
2. 클래스 없이도 객체 사이의 협력 관계를 구축하는 것이 가능하며 상속 없이도 다형성 구현이 가능하다.
3. 클래스 기반의 상속과 객체 기반의 위임 사이에 기본 개념과 메커니즘을 공유한다.

### 나만의 정리

다형성보다는 상속관계에서 메서드 전달을 설명하는 장 이다.

솔직히 여기서 설명하는 내용이 다형성과 어떻게 직접적인 관련이 있는지 이해하기 힘들다. 동일한 메시지로 다양한 메서드를 호출한다는게 포함다형성인데, 그게 상속에서 메시지를 위임하는 것과 어떻게 연관이 있는거지?

# 13. 서브클래싱과 서브타이핑

이번 장에서는 올바른 타입 계층을 구성하는 원칙을 살펴 볼 것이다.

## 13.1 타입

타입이란?

### 개념 관점의 타입

- 사물의 종류
    - 예) 자바, C, 루비(객체,인스턴스) → 프로그래밍 언어(타입)
- 타입의 요소
    - 심볼(symbol)
    - 내연(intension)
    - 외연(extension)

### 프로그래밍언어 관점의 타입

- 비트 묶음에 의미를 부여하기 위해 정의된 제약과 규칙
- 두 가지 목적
    - 타입에 수행될 수 있는 유효한 오퍼레이션의 집합을 정의
    - 타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥을 제공

### 객체지향 패러다임 관점의 타입

- 객체의 타입
  = 객체가 수신할 수 있는 메시지의 종류를 정의하는 것
  = 객체의 퍼블릭 인터페이스를 정의하는 것
- 동일한 퍼블릭 인터페이스를 제공하는 객체들은 동일한 타입으로 분류된다
    - 이는 객체에게 중요한 것이 '속성'이 아닌 '행동'이라는 것을 상기시킨다.

## 13.2 타입 계층

### 타입 사이의 포함관계

- 타입은 집합 관계로 표현할 수 있다.
- 슈퍼 타입
    - 서브 타입의 모집합
    - 일반적
    - 일반화의 결과
    - 외연적으로 더 큼(슈퍼셋)
    - 내연적으로 더 보편적이고 추상적
- 서브타입
    - 슈퍼 타입의 부분집합
    - 구체적
    - 특수화의 결과
    - 외연적으로 더 작음(서브셋)
    - 내연적으로 더 구체적이고 문맥 종속적

### 객체지향 프로그래밍과 타입 계층

- 객체지향 프로그래밍에서 타입의 관계란..
    - 퍼블릭 인터페이스가 타입 간의 관계를 형성하는 기준
    - 슈퍼타입 : 서브타입이 정의한 퍼블릭 인터페이스를 일반화시켜 상대적으로 범용적이고 넓은 의미로 정의한 것
    - 서브타입 : 슈퍼타입이 정의한 퍼블릭 인터페이스를 특수화시켜 상대적으로 구체적이고 좁은 의미로 정의한 것
- 중요한 것은!
    - 서브타입의 인스턴스는 동시에 슈퍼타입의 인스턴스이기도 하다!!

## 13.3 서브클래싱과 서브타이핑

- 객체지향 프로그래밍 언어에서
    - 타입 구현은 클래스를 이용해서
    - 타입 계층은 (일반적으로) 상속을 이용해서
        - 부모클래스 - 슈퍼타입, 자식클래스 - 서브타입
- 타입 계층을 구현할 때 지켜야 하는 제약사항과, 더 특수한 퍼블릭 인터페이스(서브타입의 인터페이스)란 무엇인지 알아본다.

### 언제 상속을 사용해야 하는가?

- 언제 타입계층을 위해 올바르게 상속을 사용했다고 볼 수 있을까?
- 마틴 오터스키의 두 가지 질문
    - 상속 관계가 is-a 관계를 모델링하는가?
    - 클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방한가?(행동 호환성 만족) (더 중요!)

### is-a 관계

- "{서브타입} 은 {슈퍼타입} 이다." 라고 말 할 수 있는지
- 하지만, is-a 관계는 단편적으로 받아들여선 안된다.'
    - 새, 펭귄, fly() 예시
    - 어휘적인 정의가 아니라, 기대되는 행동에 따라 타입 계층을 구성해야 한다.
    - 즉, 타입 계층의 의미는 행동이라는 문맥에 따라 달라질 수 있다.
    - 그러므로, 슈퍼타입과 서브타입 관계에서는 is-a보다 행동 호환성이 더 중요하다.

### 행동 호환성

- 두 타입 사이에 행동이 호환될 경우에만 타입 계층으로 묶어야 한다.
    - = 클라이언트가 두 타입이 동일하게 행동할 것이라고 기대한 경우
    - 클라이언트는 '새'가 모두 '날 수 있다'고 기대한다.
    - 그러므로 '펭귄'은 '새' 의 서브클래스로 두면 안 된다.

### 클라이언트의 기대에 따라 계층 분리하기

1. 클라이언트의 기대에 따라 상속 계층을 분리

   !https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9c5d6d4f-0442-4b53-8e88-6eb49ea02eb8/Untitled.png

2. 클라이언트에 따라 인터페이스를 분리

!https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ebed9f52-7612-4874-9156-3ac46222555b/Untitled.png

- 만약 코드를 재사용하고싶다 하더라도, Penguin이 Bird를 상속받는 것은 안 좋다.

!https://s3-us-west-2.amazonaws.com/secure.notion-static.com/18b24ad4-4a79-4c01-88cc-dd7febdb7ffc/Untitled.png

- 실제로 13.5처럼 클라이언트에 따라 인터페이스를 분리하면, 변경에 대한 영향을 더 세밀하게 제어할 수 있다.
- 인터페이스 분리 원칙
- 쓸모없는 상속 계층은 과감히 빼자!
    - 중요한 것은 요구사항과 클라이언트의 기대이다.

### 서브클래싱과 서브타이핑

- 서브클래싱 : 코드 재사용을 목적으로 상속을 사용하는 경우
  = 구현 상속, 클래스 상속
- 서브타이핑 : 타입 계층을 구성하기 위해 상속을 사용하는 경우
  = 인터페이스 상속
- 대부분의 프로그래밍 언어들은 인터페이스와 구현 상속을 구분하고 있지 않지만, 프로그래머들은 실제로 구분해서 사용하고 있다.
- 올바른 상속 관계를 구축하기 위한 지침
    - 행동 호환성(대체 가능성)을 만족해야 한다.
        - 행동 호환성 : 서브타입이 슈퍼타입이 하는 모든 행동을 동일하게 할 수 있어야 한다.
        - 대체 가능성 : 부모 클래스를 자식 클래스로 대체하더라도 시스템이 문제없이 동작할 것이라는 것을 보장해야 한다.
        - = 리스코프 치환 원칙


## 13.4 리스코프 치환 원칙

올바른 상속 관계의 특징을 정의

- 자식 클래스가 부모 클래스와 행동 호환성을 유지함으로써 부모 클래스를 대체할 수 있도록 구현된 상속 관계만을 서브타이핑이라고 불러야 한다.
- '클라이언트 관점'에서 행동이 호환되는지
- 예시 - Rectangle과 Square

### 클라이언트와 대체 가능성

- 자식 클래스가 부모 클래스를 대체하기 위해서는 부모 클래스에 대한 클라이언트의 가정을 준수해야 한다.
- 클라이언트와 격리한 채로 본 모델은 의미 있게 검증하는 것이 불가능하다.

### is-a 관계 다시 살펴보기

- 어휘적으로 보지 말고 클라이언트 입장에서 is-a 관계가 성립하는지 보라
- 이 때, 속성이 아닌 객체의 '행동'에 중점을 두고 비교하라
- is-a 관계를 행동이 호환되는 타입에 이름을 붙이는 가이드로 생각하라

### 리스코프 치환 원칙은 유연한 설계의 기반이다

- 리스코프 치환 원칙을 따르는 설계는 유연하고 확장성이 높다.
- 리스코프 치환 원칙은 개방-폐쇄 원칙을 만족하는 설계의 전제 조건이다.
- 예시 - OverlappedDiscountPolicy

### 타입 계층과 리스코프 치환 원칙

- 타입 계층은 상속 외에도 다양한 방법으로 구현할 수 있다.
    - 상속이 아니더라도, 리스코프 치환 원칙을 준수해야 한다.

## 13.5 계약에 의한 설계와 서브타이핑

자식 클래스가 부모 클래스를 대체할 수 있다는 뜻은?
클라이언트 관점에서 자식 클래스가 부모 클래스의 행동을 보존한다는 의미는?

- 계약에 의한 설계 : 클라이언트와 서버 사이의 협력을 의무와 이익으로 구성된 계약의 관점에서 표현하는 것.
    - 사전조건
    - 사후조건
    - 클래스 불변식
- 부록 A - "계약에 의한 설계" 또는 '실용주의 프로그래머 21장'(https://github.com/harkony/blind-study/blob/master/pragmatic-programmer/part4/chapter21-22.md)을 참고
- 서브타입이 리스코프 치환 원칙을 만족시키기 위해서는 클라이언트와 슈퍼타입 간에 체결된 '계약'을 준수해야 한다.
- 그림 13.8의 DiscountPolicy 클래스의 서브클래스들은 calculateDiscountAmount() 메서드를 그대로 상속받기 때문에 계약을 변경하지 않는다. 따라서 서브타이핑 관계가 맞다.

### 서브타입과 계약

만약 calculateDiscountAmount() 메서드를 오버라이딩 한다면 계약이 변경된다. 이 때 유의할 점은...

- 서브타입에 더 강력한 사전조건을 정의할 수 없다.
- 서브타입에 슈퍼타입과 같거나 더 약한 사전조건을 정의할 수 있다.
- 서브타입에 슈퍼타입과 같거나 더 강한 사후조건을 정의할 수 있다.
- 서브타입에 더 약한 사후조건을 정의할 수 없다.
- 계약에 의한 설계는 클라이언트 관점에서의 대체 가능성을 계약으로 설명해 준다.

부록 B "타입 계층의 구현"을 참고하라.

## 13장 개인 정리

- '상속'은 다양한 기능을 제공해주지만, 우리 개발자들은 이를 '타입 계층'형성을 위해 사용해야 한다.
- 혹시 어휘 관점에서만 상속 관계를 판단하고 있지 않니?
  → 상속이 제대로 이루어졌는지 확인하기 위해 행동 호환성 확인
    - 리스코프 치환 원칙
    - 계약에 의한 설계
- 인터페이스 분리 원칙

# Chapter 14. 일관성 있는 협력

- prologue

- 객체지향 설계의 목표는 적절한 책임을 수행하는 객체들의 협력을 기반으로 결합도가 낮고 재사용 가능한 코드 구조를 창조하는 것이다.
- 가능하면 유사한 기능을 구현하기 위해 유사한 협력 패턴을 사용하라.
    - 재사용을 위해서는 객체들의 협력 방식을 일관성 있게 만들어야 한다.
    - 또한 일관성 있는 설계는 코드를 이해하기 쉽게 만들어준다.

## 14.1 핸드폰 과금 시스템 변경하기

- 일관성 없는 구현 예시

!https://s3-us-west-2.amazonaws.com/secure.notion-static.com/46ace5b0-c892-4c89-a63e-bee05a32e1da/Untitled.png

- 비일관성의 문제점
    - 새로운 구현의 추가 어려움
    - 기존의 구현 이해 어려움
- 유사한 기능은 유사한 방식으로 구현해야 한다.
    - 그리고 객체지향에서 기능을 구현하는 유일한 방법은 객체 사이의 협력을 만드는 것이다.
    - 그러므로, 유사한 기능들에 대해서 협력을 일관성 있게 만들어야 한다.


## 14.2 설계에 일관성 부여하기

- 어떻게 일관성을 부여할까?

- 일관성 있는 설계를 만드는 방법의 조언
    1. 다양한 설계경험을 익힐 것
    2. 디자인 패턴을 학습하고 변경이라는 문맥 안에서 적용해 볼 것.
- 협력을 일관성 있게 만들기 위한 기본 지침
    - 변하는 개념을 변하지 않는 개념으로부터 분리하라.
    - 변하는 개념을 캡슐화하라.
    - 이는 훌륭한 구조 설계의 기본원칙이기도 하다.

### 조건 로직 대 객체 탐색

- 절차지향 프로그램에서 변경을 처리하는 전통적인 방법은 조건문의 분기를 추가하거나 수정
- 객체지향에서의 방법은 조건 로직을 객체 사이의 이동으로 바꾸는 것.
- 다형성은 조건 로직을 객체 사이의 이동으로 바꾸기 위해 객체지향이 제공하는 설계 기법이다.
- 객체지향적인 코드는 조건을 판단하지 않는다. 단지 다음 객체로 이동할 뿐이다.
- 조건 로직을 객체 사이의 이동으로 대체하기 위해서는 큰 클래스를 작은 클래스들로 분리해야 한다.
    - 기준은 변경의 이유와 주기이다.
    - 단일 책임 원칙을 따르도록 클래스를 분리해야 한다.
- 이렇게 되면 인스턴스들 사이의 협력 패턴에 일관성을 부여하기 더 쉬워지는데
    - 유사한 행동을 수행하는 작은 클래스들이 자연스럽게 역할이라는 추상화로 묶이게 되며,
    - 역할 사이에서 이뤄지는 협력 방식이 전체 설계의 일관성을 유지할 수 있게 이끌어주기 때문.
- 변하는 개념을 별도의 서브타입으로 분리한 후, 이 서브타입들을 클라이언트로부터 캡슐화
    1. 조건문을 개별적인 객체로 분리
    2. 객체들과 일관성 있게 협력하기 위해 타입 계층 구성
    3. 타입 계층을 클라이언트로 분리하기 위해 역할 도입
    4. 최종적으로 역할을 추상 클래스와 인터페이스로 구현
- 추상화에 대한 의존은 결합도를 낮추고, 대체 가능한 역할로 구성된 협력을 설계할 수 있게 해준다.
- 따라서 선택하는 추상화의 품질이 캡슐화의 품질을 결정한다.
- 캡슐화 기법들
    - 6장 : 인터페이스 설계 원칙
    - 8, 9장 : 의존성 관리 기법
    - 10장 : 상속
    - 11장 : 합성
    - 13장 : 리스코프 치환원칙
- 변경에 초점을 맞추고 캡슐화의 관점에서 설계를 바라보면 일관성 있는 협력 패턴을 얻을 수 있다.

### 캡슐화 다시 살펴보기

- 캡슐화는 변할 수 있는 모든 '개념'을 감추는 것이다.
- 캡슐화의 가장 대표적인 예는, 객체의 퍼블릭 인터페이스와 구현을 분리하는 것

!https://s3-us-west-2.amazonaws.com/secure.notion-static.com/296d47af-355f-48d9-bbe5-c8852b5d0d70/Untitled.png

- 다양한 캡슐화의 종류
    - 데이터 캡슐화
    - 메서드 캡슐화
    - 객체 캡슐화
    - 서브타입 캡슐화

!https://s3-us-west-2.amazonaws.com/secure.notion-static.com/63c60aed-b090-44ac-be86-a40baa90bd04/Untitled.png

- 코드 수정으로 인한 파급 효과를 제어할 수 있는 모든 기법이 캡슐화의 일종이다.
    - 개별 객체에 대한 변경을 관리
        - 데이터 캡슐화
        - 메서드 캡슐화
    - 협력에 참여하는 객체들의 관계에 대한 변경을 관리
        - 객체 캡슐화
        - 서브타입 캡슐화
- 협력을 일관성 있게 만들기 위해 사용하는 가장 일반적인 캡슐화는 서브타입 캡슐화와 객체 캡슐화를 조합하는 것.
    - 서브타입 캡슐화 <- by 인터페이스 상속
    - 객체 캡슐화 <- by 합성
- 서브타입 캡슐화와 객체 캡슐화의 적용 방법
    - 서브타입 캡슐화 : 변하는 부분을 분리해서 타입 계층을 만든다 => 인터페이스 상속
    - 객체 캡슐화 : 변하지 않는 부분의 일부로 타입 계층을 합성한다 => 합성
- 변경의 이유에 따라 캡슐화 할 수 있는 더 다양한 방법은 디자인 패턴을 통해 더 배울 수 있다.

## 14.3 일관성 있는 기본 정책 구현하기

- 일관성 있는 구현 예시

### 변경 분리하기

- 변하지 않는 개념과 변하는 개념을 분리

!https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f39464bf-d0da-4c4d-8b1a-1f9e56d822a6/Untitled.png

- 적용 조건의 세부 내용이 변화에 해당한다.

### 변경 캡슐화하기

- 변하는 부분의 공통점을 추상화하고, 변하지 않는 부분이 오직 이 추상화에만 의존하도록 관계를 제한하여 변경을 캡슐화한다.
    - 변하지 않는 것 : 규칙
    - 변하는 것 : 적용조건
- 서브타입 캡슐화 : '규칙'으로부터 '적용조건'을 분리해서 추상화 한 후 시간대별, 요일별, 구간별 방식을 이 추상화의 서브타입으로 만든다
- 객체 캡슐화 : 규칙이 적용조건을 표현하는 추상화를 합성 관계로 연결한다.

!https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7bb10436-3ee4-49d9-9c28-37bf1090d78e/Untitled.png

- 변하는 FeeCondition의 서브타입은 변하지 않는 FeeRule로부터 캡슐화된다.
  -> feeRule이'적용 조건'이라는 변경에 대해 캡슐화 된다.

### 협력 패턴 설계하기

### 추상화 수준에서 협력 패턴 구현하기

- 변하는 것과 변하지 않는 것을 분리하고 변하는 것을 캡슐화한 코드는, 오로지 변하지 않는 것과 추상화에 대한 의존성만으로도 전체적인 협력을 구현할 수 있다.
- 변하는 것은 추상화 뒤에 캡슐화 되어 숨겨져 있기 때문에 전체적인 협력의 구조에 영향을 미치지 않는다.

### 구체적인 협력 구현하기

- 각 서브타입의 실제 구현 예시
- 기능 추가 시 따라야 하는 구조를 강제
    - 설계의 일관성 유지
    - 코드 이해가 쉬워짐
    - 개발자는 작은 문제에 집중할 수 있는 자유
    - 개념적 무결성을 유지
- 협력을 설계한다면, 기존의 협력 패턴을 따를 수 없는지 고민하라(개념적 무결성을 지키는 방법).

### 협력 패턴에 맞추기

- 개념적 무결성을 무너뜨리는 것보다는 약간의 부조화를 수용하는 편이 더 낫다.

!https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7af24fff-945e-43a5-bf95-81a289ef33df/Untitled.png

- 지속적으로 개선하라
    - 협력은 고정된 것이 아니다.
    - 맹목적으로 일관성을 맞추는 것이 아니라 달라지는 변경의 방향에 맞춰 지속적으로 리팩터링하라.

### 패턴을 찾아라

- 변경의 방향을 파악
- 변경에 탄력적으로 대응할 수 있는 다양한 캡슐화 방법과 설계 방법을 익힌다.
- 협력을 일관성 있게 만든다는 것 -> 유사한 변경을 수용할 수 있는 협력 패턴을 발견하는 것.

## 개인 정리

- 변하는 것과 변하지 않는 것을 분리하고, 변하는 것의 공통점을 찾아 추상화 한 뒤, 클라이언트가 추상화된 것을 바라보게 한다.
- 그렇게 하면 구체클래스를 논하지 않더라도 전체적인 협력을 바라볼 수 있게 된다.
- 일관적인 시스템 구조를 만들 수 있는 방법이다.
- 즉, 개방-폐쇄 원칙을 따르도록 코드를 설계하라는 뜻
- 실제 구현 코드는 주의깊게 안봤는데 나중에 한 번 봐도 좋을듯.

### 질문거리

- 그림 14.9 질문
- 그림 14.16처럼 설계하면 feeRule이 동일한 타입의 feeCondition을 가지고 있도록 제한할 수 없지않나? BasicRatePolicy가 다양한 feeRule을 가지고, 각각의 feeRule은 동일한 feeCondition타입을 가지고 있다는 것이 전제인 것 같은데..

# Chapter 15. 디자인 패턴과 프레임워크

- 14장의 일관성 있는 협력을 빠르고 쉽게 구현하기 위한 두 가지 방법인 '디자인 패턴'과 '프레임워크'에 대해 알아본다.

- 디자인 패턴 :
  설계에서 반복적으로 발생하는 문제에 대해 반복적으로 적용할 수 있는 해결 방법
  협력을 일관성 있게 만들기 위해 재사용할 수 있는 설계의 묶음
- 프레임워크 :
  설계와 코드를 함께 재사용.
  애플리케이션의 아키텍처를 구현 코드의 형태로 제공
  일관성 있는 협력을 제공하는 확장 가능한 코드

## 15.1 디자인 패턴과 설계 재사용

- 디자인 패턴이란?

- 패턴이란 용어가 풍기는 미묘한 뉘앙스? : 패턴은 다양한 컨텍스트에서 유용한 '아이디어'
- 다양한 크기의 프로젝트 조직을 구성하는 방법, 프로젝트 일정을 추정하는 방법, 스토리 카드나 백로그를 통해 요구사항을 관리하는 방법과 같이 반복적인 규칙을 발견할 수 있는 모든 영역이 패턴의 대상이 될 수 있다.
- 패턴은 홀로 존재하지 않는다 - 패턴간의 집합, 패턴 언어, 패턴 시스템

### 패턴 분류

- 아키텍처 패턴 : 소프트웨어 전체 구조를 결정
- 분석 패턴 : 다른 패턴과 다르게 기술적인 문제가 아닌 도메인 내의 개념적인 문제를 해결
- 디자인 패턴 : 설계 문제 해결
- 이디엄 : 특정 언어에 국한된 하위 레벨 패턴

### 패턴과 책임-주도 설계

- 패턴은 공통으로 사용할 수 있는 역할, 책임, 협력의 탬플릿이다.
- STRATEGY, BRIDGE, OBSERVER, COMPOSITE 패턴 예시
- 특정 상황에 적용 가능한 패턴을 잘 알고 있다면 책임 주도 설계의 절차를 하나하나 따르지 않고도 시스템 안에 구현할 객체들의 역할과 책임, 협력 관계를 빠르고 손쉽게 구성할 수 있다.
- 패턴의 구성 요소는 클래스가 아닌 '역할'이다. → 특정 구현 방식을 강제하는 것이 아님!
- 즉 구체적인 구현 방법에 대해서는 제한이 없다. → 현재의 요구에 맞게 구조를 수정해야 한다.
- 다양한 방법의 패턴 템플릿 구현

!https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8ba264ef-24c0-4f2f-8abb-376583393a61/Untitled.png

!https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f1543246-141b-43ab-9f41-bc40a0851120/Untitled.png

!https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8e1deffc-a1a9-435c-9922-64057ab5077e/Untitled.png

### 캡슐화와 디자인 패턴

- 각 디자인 패턴의 다양한 캡슐화 방법에 대해서 설명(합성, 상속)
- 어떤 디자인 패턴이 어떤 변경을 캡슐화하는지, 어떤 방법으로 캡슐화 하는지 이해하는 것이 중요하다.
- STRATEGY, TEMPLATE METHOD, DECORATOR 패턴 예시

### 패턴은 출발점이다

- 디자인 패턴이 현재의 요구사항이나 적용 기술, 프레임워크에 적합하지 않다면 패턴을 그대로 따르지 말고 목적에 맞게 패턴을 수정하라.
- 패턴 만능주의 조심

## 15.2 프레임워크와 코드 재사용

- 프레임워크란?

### 코드 재사용 대 설계 재사용

- 프레임워크란
    - 설계 재사용과 코드 재사용을 적절한 수준으로 조합한 결과
    - 추상 클래스나 인터페이스를 정의하고 인스턴스 사이의 상호작용을 통해 시스템 전체 혹은 일부를 구현해 놓은 재사용 가능한 설계 - 구조적 측면
    - 애플리케이션 개발자가 현재의 요구사항에 맞게 커스터마이징할 수 있는 애플리케이션의 골격(skeleton) - 사용 목적
    - 애플리케이션 아키텍처, 설계 결정과 그 기반 코드, 애플리케이션 확장을 위한 추상클래스와 인터페이스의 집합 그리고 다양한 종류의 재사용 가능한 컴포넌트를 제공

### 상위 정책과 하위 정책으로 패키지 분리하기

- 변하지 않는 것(상위 정책)을 별도의 패키지로 분리, 별도의 배포 단위로 만든 것이 프레임워크
- 의존성 역전 원리(추상화 의존), 일관성 있는 협력과 관련

### 제어 역전 원리

- 의존성 역전의 원리는 객체지향의 핵심 요소이며, 프레임워크의 가장 기본적인 설계 메커니즘이다.
- 의존성 역전은 의존성의 방향 뿐 아니라 제어 흐름의 주체 역시 역전시킨다.
- 제어 역전(Inversion of Control) 원리 또는 할리우드(Hollywood) 원리
- 기존에는 애플리케이션의 코드가 재사용 가능한 라이브러리나 툴킷 코드를 호출했다면, 제어가 역전된 프레임워크에서는 프레임워크가 애플리케이션에 속하는 (우리가 작성한)서브클래스의 메서드를 호출시킨다.
- 훅(Hook) : 프레임 워크가 비워둔, 애플리케이션에 따라 달라질 수 있는 특정한 동작. 우리가 작성해야 할 구체코드.
- 이러한 제어의 역전이야 말로 프레임 워크의 핵심 개념이자 코드 재사용의 근간이다.

## 15장 궁금한 점

아키텍처 패턴과 프레임워크의 차이점?

→ 프레임워크가 특정 아키텍처 패턴의 골격을 구현한거겠지.