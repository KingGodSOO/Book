(초판)도메인 주도 개발 시작하기 - 최범균

2024/07/17 ~ 2024/10/14 1회독 완료

2024/10/20 ~  2025/01/01 2회독 완료

# 1장. 도메인 모델 시작하기

## 1.1 도메인이란?

~~소프트웨어로~~ 해결하고자 하는 문제 영역 = 온라인 쇼핑몰 = 도메인

도메인은 다수의 하위 도메인으로 구성 = 주문, 정산, 회원 등

## 1.2 도메인 전문가와 개발자 간 지식 공유

도메인에 대한 정확한 이해지식을 바탕으로 도메인 전문가, 개발자, 이해관계자 모두 직접 대화하는게 가장 효과적이며 요구사항 전달에 왜곡을 줄일 수 있다.

## 1.3 도메인 모델

여러 정의가 있지만 기본 정의는 도메인 모델은 특정 도메인을 개념적으로 표현한 것.

도메인 모델링 중 하나 : 객체 모델. 기능과 데이터를 함께 보여줌.

상태 다이어그램 - 프로세스별 상태를 나타내는 도메인 모델링

위 모델링은 UML 표기법이 적합하지만 외에는 그래프, 수학공식 등 다양한 방법을 이용할 수 있다. 모든 표현방식 이용 가능.

구현 모델은 개념 모델과 다른 것이지만, 구현 모델이 개념 모델을 최대한 따르게 할 수 있다. 객체지향 언어를 이용해 구현 모델을 객체 모델에 최대한 가깝게 구현하는 것이 그 예.

모델의 구성 요소는 특정 도메인으로 한정할 때 의미가 완벽해지기 때문에, 하위 도메인(컨텍스트)마다 별도로 모델을 만들어야 함. 동일한 용어라도 의미가 달라질 수 있기 때문.

## 1.4 도메인 모델 패턴

[엔터프라이즈 애플리케이션 아키텍쳐 패턴(마틴 파울러 저)]의 도메인 모델 패턴 = 아키텍쳐 상의 도메인 계층을 객체 지향 기법으로 구현하는 패턴.
표현 - 응용 - **도메인** - 인프라스트럭쳐
‘도메인 모델’이란 위 챕터에서 정의된 의미도 있지만, 도메인 계층의 구현 객체 모델을 언급할 때도 동일하게 사용되며 이 책에서도 해당 의미로 표현.

개념모델 → 구현모델

## 1.5 도메인 모델 도출

요구사항 → 도메인 객체 모델 구현 방식 설명

## 1.6 엔티티와 밸류

- 엔티티
    - 식별자를 가짐
- 밸류
    - 개념적으로 완전한 하나
    - 불변성 권장

주문 번호, 금액 등에 밸류타입을 사용하여 의미를 확실하게 하고 공통 구현을 강화하는 것을 추천.

## 1.7 도메인 용어와 유비쿼터스 언어

유비쿼터스 언어 : 전문가, 관계자, 개발자가 함께 사용하는 도메인 관련 공통 언어

알맞은 영단어를 찾는 노력을 게을리 하지 말자!

# 2. 아키텍쳐 개요

## 2.1 네 개의 영역

- 표현
    - 클라이언트 요청을 받아 변환, 응용 계층에 전달. 이후 응답을 변환하여 클라이언트에게 전달
- 응용
    - 로직 수행 x. 도메인에 로직 수행 위임
- 도메인
    - 도메인 모델 구현
- 인프라스트럭쳐
    - 구현 기술을 다룸. 다른 계층에서는 구현 기술 사용X

## 2.2 계층 구조 아키텍쳐

표현 → 응용 → 도메인 → 인프라스트럭쳐

상위 계층이 인프라스트럭쳐 영역의 기술에 의존하지 않게 구현하려면 ? DIP를 적용해야 한다.

## 2.3 DIP

Dependency Inversion Principle. 의존성 역전 원칙

고수준 → 저수준 의존이 아닌, 저수준 → 고수준 의존

1. 추상화 및 고수준 모듈의 추상화(인터페이스) 의존.
2. 이 때, 추상화 클래스는 고수준 모듈에 위치

이렇게 되면, 계층 간 의존 관계는 “표현 ← 응용 ← 도메인 ← 인프라스트럭쳐” 가 된다.

구현 기술에 따라 도메인에 구현 기술이 녹아나거나 추상화가 어려운 케이스가 있을 수 있는데 DIP의 트레이드오프를 잘 고려하여 적용하자.

## 2.4 도메인 영역의 주요 구성요소

- Entity : 고유의 식별자를 갖는 객체. 도메인의 고유한 개념을 표현. 데이터와 데이터 관련 기능을 함께 제공
- Value : 식별자X. 하나의 값을 표현.
- Aggregate : 연관 엔티티들과 밸류 객체들을 하나로 묶은 것
- Repository : 도메인 모델의 영속성 처리
- Domain Service : 특정 엔티티에 속하지 않은 도메인 로직 제공

도메인 모델은 DB 테이블 엔티티와 다름. 1. 데이터에 대한 기능이 있으며 2. 두 개 이상의 데이터를 밸류로 표현할 수 있음. 즉, JPA 도메인 Entity는 단순 테이블 매핑 엔티티로 생각하여 구현하면 안된다는 뜻!

애그리거트는 관련 객체를 하나로 묶은 군집. 해당 책에서 설명하는 주문 애그리거트는 주문 도메인 엔티티 하나와 하위 여러 밸류 객체를 포함. 즉 주문 도메인 객체가 주문 애그리거트를 표현함과 동시에 애그리거트 루트가 된다.

리포지터리는 요구사항에서 도출된 모델이 아닌 구현을 위한 도메인 모델이며 도메인 객체를 영속화하는데 필요한 기능을 추상화한 고수준 모듈. 애그리거트 단위로 처리하게 된다.

## 2.5 요청 처리 흐름

응용 계층에서 트랜잭션을 관리.

## 2.6 인프라스트럭쳐 개요

표현, 응용, 도메인 영역을 지원. 프레임워크, 구현 기술 등을 지원한다.
인프라스트럭쳐 접근 시 각 계층에서 추상 클래스를 통해 접근하는게 좋지만(DIP) 무조건 인프라스트럭쳐에 대한 의존을 없애는 건 무모함. ex) @Transactional, @Entity(@Table), 표현계층의 스프링 MVC 구현 등

## 2.7 모듈 구성

각 계층과 도메인 별로 모듈 구성 예시를 설명. 각 계층을 다른 패키지로 분리하긴 하지만 정해진 규칙이나 정답은 없다. 작가 개인적으로 한 패키지에 10~15개 미만의 타입 개수를 유지하려고 노력한다고 함.

# 3. 애그리거트

## 3.1 애그리거트

개별 객체 수준의 도메인 모델들을 상위 수준 모델로 묶어준 것.

- 도메인 규칙, 요구사항등에 의해 라이프사이클이 동일하다.
- 객체는 하나의 애그리거트에만 속하며, 본인이 속한 애그리거트만 관리한다.
- 도메인을 이해할 수록 애그리거트 크기는 작아진다. 대부분 한 개의 엔티티라고 한다.

## 3.2 애그리거트 루트

애그리거트 관리 주체, 대표 엔티티.
애그리거트에 속하는 다른 모델은 애그리거트 루트 모델에 직/간접적으로 속하게 된다.

애그리거트가 제공해야 할 도메인 기능을 구현, 제공. 이 때 일관성이 깨지지 않도록 조심해야 함.

유일한 애그리거트 접근 권한자. 외부에서 접근을 막고 단일 관리 책임을 가짐으로써 일관성을 유지할 수 있다.
이를 위해서는 아래 두 가지를 지켜야함!

- public set메서드 제거
- 밸류는 불변으로 구현 → 혹 불가능하면 패키지 또는 protected 접근 제한자를 두자.

애그리거트는 참조 또는 위임으로 애그리거트의 데이터를 구하거나 변경하는 역할을 가진다.

트랜잭션 범위는 가능하면 한개 애그리거트에 한개 트랜잭션.
한 번에 여러 애그리거트를 변경해야 할 때면 이벤트 사용을 고려.
어쩔 수 없이 하나의 트랜잭션에서 여러 애그리거트를 변경해야 하는 경우 응용 서비스에서 각 애그리거트를 처리

## 3.3 리포지터리와 애그리거트

하나의 애그리거트 = 하나의 레포지토리
애그리거트가 저장될 때 애그리거트를 구성하는 모든 데이터가 함께 영속화되야 하고,
애그리거트가 조회될 때 애그리거트를 구성하는 모든 데이터가 포함되야 한다.

*JPA를 이용하여 하나의 애그리거트를 도메인 모델로 구현할 때, 내부의 밸류타입은
@Component로, 상황에 따라서는 @Entity로 구현할 수도 있다.

## 3.4 ID를 이용한 애그리거트 참조

애그리거트(루트)는 다른 애그리거트(루트)를 참조할 수 있다.

이 때 참조방식은 객체 **직접 참조** 방식과 ID를 이용한 **간접 참조** 두 가지가 가능하다.

직접 참조는 다른 애그리거트를 변형시키는 오용 가능성이 있으며, 지연로딩과 즉시로딩을 잘 선택하지 않으면 성능이슈가 있을 수 있다. 또한 DBMS가 분리되는 식의 인프라 확장이 있는 경우 구현을 바꿔야 한다.

간접 참조는 애그리거트 물리적 연결을 제거하여 경계를 확실하게 하고 복잡도를 낮춰준다. 또한 구현기술을 분리할 수도 있다.
응용 서비스에서 연관 애그리거트 ID를 이용해 조회할 경우 지연로딩과 동일한 효과이므로 적절하게 구현하지 않으면 N+1 이슈에 빠질 수 있다. 책에서는 DAO를 이용해 조회 전용 쿼리를 해결 구현 예시로 들었다. DAO 등 조회 전용 쿼리를 분리하는 것은 CQRS의 개념에 구현기술 분리 등 다양한 장점이 있다.

추가로, 애그리거트가 각 저장소에 분리돼있다면 **캐시** 또는 **조회 전용 저장소**를 고려해야 한다.

## 3.5 애그리거트 간 집합 연관

개념적으로 존재하는 1-N, M-N 양 방향 연관을 모두 구현할 필요는 없다(성능 상 이슈가 있을 수 있음).
책에서는 카테고리 - 상품 관계가 1-N, M-N일 때 요구사항에 따라 카테고리에서 상품 참조를 구현할 필요가 없을 수 있다고 설명한다. 이에 대해 1-N 관계에서는 ID참조를 사용하여 JpaRepository에서 조회, M-N 관계에서는 ID 컬렉션을 밸류 타입으로 저장하고 JPQL member of 연산자로 조회하는 것을 예시로 들었다.

## 3.6 애그리거트를 팩토리로 사용하기

어떤 애그리거트(A)가 다른 애그리거트(B)를 생성하는 데

- 필요한 데이터를 가지고있으며
- 조건을 판단하는 등 도메인 로직이 얽혀있다면

A에 B 생성 팩토리로 사용하는 것을 고려해보자. 도메인 로직이 응용서비스에 노출되지 않고 응집도를 가질 수 있다.
만약 생성에 여러 데이터가 사용된다면 A 메서드 내에서 다른 팩토리 객체에 생성을 위임할 수도 있다. 이 때도 도메인 로직은 응집도 유지가 가능하다.

이런 식으로 논리적으로 하나의 도메인 기능이 여러 애그리거트에 흩어져 있다면, 아래 내용들을 고려해볼 수 있겠다.

1. 별도의 도메인 서비스 구현 (7장)
2. 관련된 특정 애그리거트를 팩토리로 구현
3. 별도의 팩토리 클래스를 구현

# 4장. 리포지터리와 모델 구현

## 4.1 JPA를 이용한 리포지터리 구현

JPA를 이용해 리포지터리 구현 방법을 설명

- 리포지터리 인터페이스는 도메인 패키지에, 구현체는 인프라 패키지에 속하게 개발한다. 하지만 스프링 데이터 JPA를 사용하면 구현체를 구현할 일이 많이 줄어든다.
- 인터페이스는 애그리거트 루트를 기준으로 작성한다. 즉 조회, 저장, 삭제 모두 애그리거트 루트를 기준으로 개발하고 나머지 객체는 애그리거트 루트 안에 속하게 된다.

## 4.2 스프링 데이터 JPA를 이용한 리포지터리 구현

스프링 데이터 JPA를 이용한 리포지터리 구현방식 설명

## 4.3 매핑 구현

### 4.3.1 엔티티와 밸류 기본 매핑 구현

애그리거트 루트 = Entity로 매핑, 이에 속하는 밸류는 Embeddable로 매핑
루트 엔티티와 그에 속하는 밸류는 하나의 테이블에 매핑될 때가 많다. 이 때에 대한 예시를 보여줌.
Member테이블의 ID를 밸류 타입으로 새로 생성하고, Orderer 테이블에서 해당 밸류 타입을 매핑함으로써 간접적인 매핑을 명시적으로 처리

### 4.3.2 기본 생성자

밸류는 주로 불변으로 구현하여 기본생성자가 필요 없지만, 기술적 제약으로 protected로 구현함

### 4.3.3 필드 접근 방식 사용

마찬가지로, 매핑 처리를 위해 get/set 메서드 접근 방식을 사용하면 불필요하고 캡슐화를 해치는 메서드가 생성되므로 필드 접근 방식을 고수하는게 좋다.

### 4.3.4 AttributeConverter를 이용한 밸류 매핑 처리

하나의 컬럼으로 저장된 값을 두 개 프로퍼티로 분리해야 할 때도 있다. 컨버터를 적절하게 구현해보자.
@Converter.autoApply 속성 - 컨버터 자동 적용

### 4.3.5 밸류 컬렉션 : 별도 테이블 매핑

밸류 컬렉션 별도 테이블 매핑 - @ElementCollection, @CollectionTable(+@OrderColumn)

### 4.3.6 밸류 컬렉션: 한개 컬럼 매핑

밸류 컬렉션을 한개 컬럼에 매핑할 수도 있다. converter를 이용해 처리.

### 4.3.7 밸류를 이용한 ID 매핑

식별자를 밸류 타입으로 구현하는 방식 설명. 해당 책에서는 대부분의 식별자를 밸류타입으로 구현해서 제공하고있다.
장점은 식별자 의미 부각 및 부가 기능(메서드) 별도 구현의 용이함

### 4.3.8 별도 테이블에 저장하는 밸류 매핑

1) 애그리거트에서 루트엔티티를 뺀 나머지 구성요소는 대부분이 밸류이다.
2) 루트엔티티 외 또 다른 엔티티가 있다면 진짜 엔티티인지 의심해봐야 함.
3) 별도 테이블을 사용한다고 무조건 엔티티가 아니다. 독자적인 라이프사이클이 있는지 확인해봐야함.
4) 또, 구분하는 방법은 고유 식별자가 있는지이다. 이 때 고유식별자란 테이블의 PK가 아닌, 애그리거트 구성요소의 고유 식별자를 뜻한다.
5) 밸류 테이블 매핑은 SecondaryTable을 이용한다.
6) SecondaryTable로 매핑된 테이블은 EntityManager로 조회 시 반드시 조인된다는 문제가 있다. 이를 피하기 위해 Entity로 매핑할 수도 있지만 이는 의미를 해친다. 조회 전용 쿼리 또는 CQRS를 통해 조회 전용 기능 구현으로 해결하자.

### 4.3.9 밸류 컬렉션을 @Entity로 매핑하기

1) 기술적 한계로 인해 밸류를 Entity로 매핑해야 하는 경우가 있다. 책에서 설명하는 예제는 “상속”관련.
2) 이 때, Entity로 구현하더라도 상태를 변경하는 기능은 추가하지 않는다.
3) 모든 라이프사이클은 상위 Entity(애그리거트 루트)에 속하므로, Cascade와 orphanRemoval 옵션을 설정한다.
4) 엔티티로 지정할 경우 clear() 같은 기능을 호출할 때 밸류로 지정했을때의 그것과 생성되는 쿼리가 다르다. 성능상의 이슈와, 밸류로 구현했을 때의 불편함에 대해 트레이드오프를 잘 고려하여 구현하자.

### 4.3.10 ID 참조와 조인 테이블을 이용한 단방향 M-N 매핑

애그리거트 간 집합 연관은 성능상 이유로 피해야한다.
구현이 필요하다면 ID 참조를 단방향으로 구현하는 방법을 고려하자.

## 4.4 애그리거트 로딩 전략

애그리거트에 속한 객체가 모두 모여야 완전한 하나가 된다. 즉, 애그리거트 루트를 로딩할 때, 애그리거트 루트에 속한 모든 객체가 완전해야 한다(조회, 상태 변경과 연관).

그렇지만, JPA의 지연로딩을 사용한다 하더라도 특별히 문제가 될 것은 없으므로 성능상의 이슈를 고려하여 잘 선택하자.

조회 = 조회전용 기능 및 모델 구현, 상태변경 = JPA에서 지연로딩을 잘 제공하므로 적절한 로딩 방식 사용.

즉시로딩 시 카타시안 조인 발생, 이로 인한 쿼리 뻥튀기를 설명하고 있다.

## 4.5 애그리거트의 영속성 전파

애그리거트는 완전한 상태여야 한다 = 애그리거트 루트가 저장/삭제될 때 애그리거트 구성요소가 함께 처리되야 한다. 영속성을 전파하는 기술(cascade 옵션 등)을 설명.

## 4.6 식별자 생성 기능

- 사용자가 직접 생성
- 도메인 로직으로 생성
    - 도메인 서비스 혹은 레포지토리에 위치
- DB를 이용한 일련번호 사용

## 4.7 도메인 구현과 DIP

JPA를 사용하면 필연적으로 도메인 계층이 구현 계층에 의존하게 된다. 즉 DIP를 해친다.
명확하게 의존을 없애려면 추가적인 인터페이스 구현하거나 연동용 클래스를 따로 둬야 한다.
저자는 이는 과하다고 생각하며 애너테이션을 사용함으로써, 구조적인 유연함은 어느 정도 유지하면서 편의성과 실용성을 가져갔다고 한다.

# 5장. 스프링 데이터 JPA를 이용한 조회 기능

## 5.1 시작에 앞서

CQRS - 커맨드, 쿼리 모델 분리.
도메인 모델은 명령 모델로 주로 사용됨.
해당 장에서는 대부분 조회 모델 구현에 관한 이야기.
해당 장에서의 리포지터리는 DAO와 혼용해서 사용한다.

## 5.2 검색을 위한 스펙

Specification 을 이용하지 않고 플레인하게 구현하는 방식이 조금 재밌음.

## 5.3 스프링 데이터 JPA를 이용한 스펙 구현

## 5.4 리포지터리/DAO 에서 스펙 사용하기

## 5.5 스펙 조합

위 소 챕터들은 스프링 JPA에서 제공하는 Specification 방식을 설명. 해당 방식이 필요하면 따로 공부하자.

## 5.6 정렬 지정하기

JPA query methods 및 Sort 객체에 대해 설명

## 5.7 페이징 처리하기

- Pageable 사용
- 응답 타입이 Page면 카운트 쿼리 발생
    - Pageable을 전달하더라도 응답 타입이 List면 카운트 쿼리가 발생하지 않는다고 한다.
    - 응답 타입이 List더라도 Specification과 Pageable 파라미터를 함께 사용하면 카운트 쿼리가 발생한다.
    - 잘 파악해서 필요할 때만 count쿼리 발생하도록 하자.
- 쿼리 메서드 - FirstN or TopN 메서드네임 사용

## 5.8 스펙 조합을 위한 스펙 빌더 클래스

Specification 관련.

## 5.9 동적 인스턴스 생성

조회 전용 모델을 @Query 애너테이션과 Projection 기능을 이용해 가져오는 방식에 대해 설명
JPQL을 사용하여 객체 기준으로 쿼리를 작성하면서도, 원하는 데이터를 로딩 방식애 대한 고민 없이 가져올 수 있다는 장점.

밸류타입을 출력할 때는 기본타입으로 변환하거나, 원하는 형식으로 출력되도록 프레임워크를 확장하는게 필요. 이 때 프레임워크 확장이란 뭘까?

## 5.10 하이버네이트 @Subslect 사용

쿼리 결과를 @Entity로 매핑할 수 있는 기능. 뷰 테이블 대신 사용하여 조회 전용 모델을 만들 때 유용

@Immutable, @Synchronize 애너테이션과 함께 사용할 필요가 있음.

쿼리 성능에 대해서도 검토해볼 필요가 있다.

# 6. 응용 서비스와 표현 영역

## 6.1 표현 영역과 응용 영역

1~5장은 도메인 구성요소와 구현방법에 대한 설명,
이번 장은 사용자의 요청을 도메인으로 전달하기 위한 표현 영역과 응용 영역에 관한 설명이다.
유저 → 표현영역(요청 해석) → 응용영역(요청 수행)

## 6.2 응용 서비스의 역할

1. 도메인 객체를 사용해 사용자 요청 처리
2. 트랜잭션 처리

이 외에도 아래 역할이 있으나, 이는 나중에 설명한다고 한다.

1. 접근 제어
2. 이벤트처리

핵심은 도메인 로직을 포함하지 않는 것.

## 6.3 응용 서비스의 구현

응용 서비스는 표현 영역과 도메인 영역을 연결하는 매개체 역할을 하는데, 이는 디자인 패턴의 파사드(facade)와 같은 역할이라고 한다.
응용 서비스 구현 시 고려할 사항과 트랜잭션 구현 기술 연동 등을 설명.

### 6.3.1 응용 서비스의 크기

- 하나의 서비스에 기능을 많이 넣을 경우…
    - 중복은 줄일 수 있지만
    - 코드가 길어지면서, 관련 없는 코드(특정 기능에만 필요한 필드)가 섞이게 됨
- 기능을 제한하는 것을 권장
    - 1~3개의 기능으로 제한
    - 중복되는 공통 로직은 별도 클래스로 분리

### 6.3.2 응용 서비스의 인터페이스와 클래스

필자는 인터페이스를 미 권장한다.

- 구현 클래스가 여러개이면서, 런타임에 교체하는 경우? 거의 없다.
- 테스트의 용이성 또한 TDD를 적극적으로 활용하지 않는 이상 거의 필요 없다…

** 이 부분은 고민이 필요해보인다.

### 6.3.3 메서드 파라미터와 값 리턴

- 요청 파라미터가 두개 이상인 경우 DTO 사용 → ** 확장 가능성이 있으면 DTO 사용
- 애그리거트 표현 영역으로 노출 x

** 예시 중 컨트롤러에서 요청 DTO에 별도 파라미터를 추가로 set해서 응용영역으로 전달하는 코드가 있는데 내 개인적인 생각으로는 별로 안좋은 것 같다. 요청 DTO는 불변으로 구현하는게 좋지 않을까?

### 6.3.4 표현 영역에 의존하지 않기

표현 영역의 기술을 응용 서비스로 가져오지 않기!
URL, 쿠키, Http 세션, 헤더 등

### 6.3.5 트랜잭션 처리

프레임워크가 제공하는 기능(@Transaction) 적극적으로 사용 권장

## 6.4 표현 영역

- 화면 제공(**뷰)
- 유저와 응용서비스와 연결(**API). 에러 응답도 표현 영역의 관할
- 클라이언트 세션 관리

### 6.5 값 검증

원칙적으로는 응용 서비스에서 모든 값에 대한 검증을 수행한다.
다만 현재 프레임워크에서 제공하는 기능을 통해 표현 계층에서 검증을 하는 것이 매우 쉽다. 따라서 표현 계층에서 표현 계층에서 1차 필수값 검증 후, 응용 서비스에서 2차 논리적 오류 검증하는 방식도 있다고 함(특히, 특정 응용 서비스를 이용하는 표현 계층이 한 곳인 경우). ← ** 내가 현재 하는 방식.
필자 또한 위 방식이 괜찮다고 생각했지만 요새는 응용 서비스에서 필수값 검증까지 모두 수행한다고 함.

### 6.6 권한 검사

- 권한 검사는 세 곳에서 이뤄질수 있다
    - 표현 영역 : URL 별 제한 등
    - 응용 서비스 : URL 만으로 제한이 불가능 한 경우
    - 도메인 : 인프라까지 얽힌 경우
- 스프링 시큐리티는 유연하지만 매우 복잡하다(특히 도메인 단계에서의 권한 검사까지 통합하려면 매우 어렵다). 따라서 직접 시스템에 맞는 권한 기능을 구현하는 것도 하나의 방법.

### 6.7 조회 전용 기능과 응용 서비스

단순 조회 전용인 경우 응용 서비스를 생략해도 된다

** 정말?

# 7장. 도메인 서비스

## 7.1 여러 애그리거트가 필요한 기능

여러 애그리거트가 필요한 도메인 기능이 필연적으로 있을 수 밖에 없다.
이 때 억지로 하나의 애그리거트에 구현하게 되면 애그리거트의 책임 범위가 기대한 것 보다 커져버린다.

## 7.2 도메인 서비스

도메인 영역에 위치한 도메인 로직을 표현.

- 여러 애그리거트 동시 상태변경, 혹은 계산
    - ex) 계산 로직, 계좌 이체 기능(두 개 계좌 애그리거트 사용)
- 외부 시스템 연동 케이스
    - ex) 사용자 권한 조회, 룰 엔진 등 외부 관리 할인 규칙 조회 등

### 7.2.1 계산 로직과 도메인 서비스

- ‘상태’없이 ‘로직’만 구현, 구현에 필요한 ‘상태’는 전달받음
- 도메인 의미가 드러나는 용어를 타입과 메서드명으로 짓는다.
- 도메인 서비스 사용처
    - 애그리거트
      응용서비스에서 참조한 도메인 서비스를 인자로 전달받아서 사용
      도메인 서비스 직접 참조 X
    - 응용서비스
      도메인 서비스 참조. 애그리거트를 인자로 전달하여 사용
- 도메인 로직인지 헷갈릴 때, 애그리거트의 상태를 변경하거나, 상태 값을 계산하는 로직이라면 도메인 로직이다.

### 7.2 외부 시스템 연동과 도메인 서비스

- 도메인 서비스에 추상화, 구현체는 인프라스트럭쳐 영역에 작성
- 구현체 중심이 아닌, 도메인 로직 관점에서 인터페이스 작성할 것!

### 7.2.3 도메인 서비스의 패키지 위치

domain 또는 domain.service

### 7.2.4 도메인 서비스의 인터페이스와 클래스

- 외부시스템 연동과 같이 로직이 변경되는 경우 추상화
- 도메인 서비스에 인터페이스, 구현체는 인프라스트럭쳐에 개발

# 8장. 애그리거트 트랜잭션 관리

1회독 때 이해한 내용 :

1. JPA는 단일 엔티티에 대해 동시성문제가 있는건가? -> 있는듯
2. 선점방식은 이해가 되는데, 비선점방식은 이해가 잘 안됨
3. 하나의 스레드에서 진행된다면 선점방식으류 가능하지않나
4. 다른 스레드라면, 수행 전 검증을 통해 방지가 가능하지 않나
5. 결론적으로는, 다른 스레드라는 가정 하에서 검증만으로는 확인하기 어려운 케이스(너무 많은 변경점?)에서 버져닝을 이용한 동시성 이슈를 해결하는걸까? -> 일단 이렇게 생각하자.
6. 오프라인 선점잠금은 DDD와는 큰 상관이 없어보인다.

## 8.1 애그리거트와 트랜잭션

한 애그리거트에 여러 스레드가 붙게 되면 각 스레드에서 애그리거트 일관성이 깨질 수 있다.
이를 방지하기 위해, DBMS가 기본 제공하는 트랜잭션 외 추가적으로 애그리거트를 위한 트랜잭션 처리 기법이 필요하다.

대표적으로 두 가지 방법이 있다.

- 선점 잠금(Pessimistic Lock)
- 비선점 잠금(Optimistic Lock)

## 8.2 선점 잠금

- 특정 스레드에서 어떤 애그리거트에 접근하는 시점에 접근 잠금 처리.
  다른 스레드에서는 해당 애그리거트에 접근 시도 시, 잠금되어 있다면 블로킹
  잠금 해지 시 블로킹 된 스레드에서 다시 잠금하며 접근
- 즉, 한 애그리거트에 한 스레드만 접근하도록 제한하며, 다른 스레드는 항상 최신화 된 애그리거트를 조회하여 사용하게 된다.
- 일반적으로 DBMS 행단위 잠금(ex. 오라클 : for update 구문)을 통해 구현
- 스프링 데이터 jpa에서는 @Lock 에너테이션 제공

### 8.2.1 선점 잠금과 교착 상태

- 교착상태(deadlock) : 두 개 이상의 애그리거트를 사용하는 서로 다른 스레드에서, 서로 하나의 애그리거트를 잠금함과 동시에 다른 스레드에서 잠금된 애그리거트에 접근하려 할 때 영원히 잠금상태에 빠지는 상황
- 최대 대기 시간을 지정하여 해결
- 스프링 데이터 jpa에서는 @QueryHints 에너테이션 제공

## 8.3 비선점 잠금

- 버져닝을 이용하여 잠금
- 기본 작동 원리 = DBMS 반영 시점에 변경 가능 여부를 확인
- JPA에서는 @Version 애너테이션 제공
- 응용 서비스에서 추가 처리를 통해 **다중 트랜잭션**에서의 일관성 관리가 가능
- 단일 트랜잭션 내 ⇒ 커밋 시점에 버젼이 다르면 오류 발생. DB 레벨에서 관리
- 다중 트랜잭션 내 ⇒ 클라이언트 측에서 버젼과 함께 요청, 응용서비스에서 처리 전 조회한 애그리거트와 버젼 비교하여 검증. 즉 응용서비스에서 관리
- 응용 서비스 레이어에서 버젼 검증을 통과하더라도, DB 레벨에서 검증이 실패할 수 있다. 필요 시 다르게 예외 응답하여 정보 전달.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/5e77bd9c-316a-4e86-8082-6bc082cd2469/cad3b2f0-3efa-48ce-87d4-70028c74203b/image.png)

### 8.3.1 강제 버전 증가

- JPA @Version 이용 시, 해당 엔티티 필드가 업데이트 된 경우만 버전이 올라감.
- 애그리거트 내 다른 엔티티가 업데이트 된 경우, 강제로 버전을 올려줘야 비선점 잠금이 올바로 작동.
- 스프링 데이터 JPA에서는 @Lock 에너테이션 옵션을 통해 적용 가능.

## 8.4 오프라인 선점 잠금

- Offline Pessimistic Lock
- 다중 트랜잭션 내에서, 특정 애그리거트에 대해 접근 제한처리
- 조회 시점에 lock, 수정 등 특정 액션과 함께 lock 해제
- 잠금 유효기간이 있어야 함.

### 8.4.1 오프라인 선점 잠금을 위한 LcokManager 인터페이스와 관련 클래스

- 애그리거트 ID를 포함한 lock 데이터 존재 여부를 확인하여 해당 애그리거트가 잠금됐는지 여부 판별
- 잠금 시점에 lock 데이터 생성, 해지 시점에 lock 데이터 삭제
- 직접 구현한 인터페이스를 예시로 설명

### 8.4.2 DB를 이용한 LockManager 구현

RDB를 이용해 구현하는 예시 설명

# 9장. 바운디드 컨텍스트

## 9.1 도메인 모델과 경계

도메인 모델은 각 [하위 도메인](https://www.notion.so/10c7e24f821180a5a021dc577adce4d7?pvs=21) 안에서 의미와 기능이 다르다
따라서 구현하는 하위 도메인 별로 모델을 다르게 구현해야 한다.

이 때, 하위 도메인을 ‘컨텍스트’라고 표현하며 이러한 구분의 경계를 ‘바운디드 컨텍스트’라고 부른다.

## 9.2 바운디드 컨텍스트

- 다른 용어 = 다른 컨텍스트
- 하나의 바운디드 컨텍스트 = 하나의 물리적 시스템
- 회사 사정/지식 부족에 따라 하나의 하위 도메인에서 여러 바운디드 컨텍스트가 개발될수도, 하나의 바운디드 컨텍스트에서 여러 하위도메인이 개발되는 경우도 있다.
- 하나의 바운디드 컨텍스트 안에 모든 하위도메인이 개발될 수도 있다. 이 때 도메인 모델들을 패키지로 분리하는 방법도 있다.

## 9.3 바운디드 컨텍스트 구현

- 하나의 바운디드 컨텍스트는 단일한 시스템으로서, 표현영역-응용서비스-도메인-인프라-DBMS까지 모두 포함한다.
- 각 바운디드 컨텍스트는 시스템 아키텍쳐/구현기술 등 모두 상이할 수 있다.
- 그림 9.7 - 하나의 바운디드 컨텍스트 안에서도 아키텍쳐가 분리될 수 있다. 특히 CQRS를 구현할 때 그렇다.
- 그림 9.9 - 여러 바운디드 컨텍스트에서 값을 읽어 HTML을 만드는 경우 UI 서버를 파사드 역할로 두어 바운디드 컨텍스트와 브라우저 간 간접적으로 통신하는 방법도 있다.

## 9.4 바운디드 컨텍스트 간 통합

각 바운디드 컨텍스트 간 연동이 필요할 수 있다

- 직접 통합(직접 API 호출)
    - 도메인 서비스 구현 - 해당 컨텍스트에 맞게 모델 변환하여 가져옴.
    - 인프라에서 모델 변환 처리까지 구현(중간 클래스를 둬도 됨)
      궁금한점 - 근데, 모델 변환까지 처리하려면 인프라가 도메인을 의존해야 하지 않나?
- 간접 통합(메시지 큐 사용)

핵심은, 연동되는 도메인 모델은 각 바운디드 컨텍스트에서 별개의 모델로 구현되어 다뤄진다.

MSA에서 각 마이크로 서비스는 하나의 바운디드 컨텍스트에 대입하면 맞아 떨어진다.

## 9.5 바운디드 컨텍스트 간 관계

### 1. 고객/공급자 관계

- 상류 : 공급자(서버) / 하류 : 고객(클라이언트)
- 클라이언트가 많은 경우 서버에서 요구사항 취합, ‘공개 호스트 서비스’로 제공
- 클라이언트 측에서는 서버에서 제공된 모델을 적절하게 변환해서 받아오는 ‘완충지대(Anticorruption Layer)’필요. 책 예제에서는 도메인 서비스를 구현한 조회 Client 객체가 그 역할

### 2. 도메인 모델 공유(공유커널, Shared Kernel)

- 하나의 도메인 모델을 두 바운디드 컨텍스트가 공유
- ex) 가비아 상결팀 멀티모듈 시스템 속 internal-api, external-api가 공유하는 도메인 모듈

### 3. 독립 방식(Separate Way)

- 수동 처리
- 규모가 커져 관리가 어려워지면 수동처리 역할을 대신할 ‘통합 시스템’이 필요해짐.

## 9.6 컨텍스트 맵

- 시스템 전체구조 안에서 바운디드 컨텍스트 간 관계를 표현
- 정해진 규칙은 없음.
- 주요 애그리거트나 하위 도메인, 조직 구조를 함께 표현하면 더 좋음.
- 마이크로 서비스에서 앱 간 관계 표시와 비슷.

# 10장. 이벤트

- 이벤트의 용도와 장점
- 핸들러 디스패처와 핸들러 구현 ⇒ 스프링 제공 이벤트 처리 구현 예시
- 비동기 이벤트 처리 ⇒ 세 가지 비동기 방식 설명 및 구현 예시

### 관수 요약

1. 이벤트 구조는 디자인 패턴으로 유용
2. 이벤트를 외부 저장소 사용 비동기 방식으로 사용한다면, 시스템 내부적으로는 디자인 패턴이 들어가고 외부적으로는 시스템 아키텍처가 들어간다.
3. 즉, 해당 장은 ‘이벤트’ 디자인 패턴과 ‘비동기 외부 DB’ 시스템 설계 공부에 유용한 장.

## 10.1 시스템 간 강결합 문제

ex) 주문 로직과 외부 환불 로직을 함께 처리할 때 문제점

- 트랜잭션 처리의 애매함
- 성능 이슈(외부 처리 성능에 강하게 영향)
- (주문 도메인이 환불 도메인 서비스를 파라미터로 받을때) 바운디드 컨텍스트의 강결합
    - 로직 뒤섞임
    - 확장의 어려움

이를 해소하기 위해 이벤트를 활용하면 좋다.

*** 관수 추가내용

- 도메인 컨텍스트 강결합 ⇒ 이벤트를 활용해 해결
- 트랜잭션, 성능 이슈 ⇒ 비동기(또는 트랜잭션 연계?)를 활용해 해결

## 10.2 이벤트 개요

이벤트 = 과거에 벌어 진 어떤 것.
이벤트가 발생되고, 그 이벤트에 반응하여 원하는 동작을 수행하는 기능을 구현한다.
ex) 주문 취소됨 이벤트

### 10.2.1 이벤트 관련 구성 요소

- 이벤트
- 이벤트 발생 주체 (엔티티, 값, 도메인 서비스 등)
- 이벤트 발행자(publisher)
- 이벤트 구독자(subscriber)

### 10.2.2 이벤트의 구성

- 이벤트 종류 - 클래스 이름에 ‘과거형’으로 작성
- 발생 시간
- 추가 전달 정보

### 10.2.3 이벤트 용도

- 트리거 ⇒ 특정 기능 수행
- 동기화 ⇒ 데이터 동기화

### 10.2.4 이벤트 장점

- 도메인 로직 결합 방지 (핸들러로 이동)
- 확장 용이 (핸들러 추가 구현)

## 10.3 이벤트, 핸들러, 디스패처 구현

스프링 제공 기능을 활용하여 구현한 예시

- 이벤트 클래스 : 이벤트 표현
- 디스패처 : 스프링 제공 ApplicationEventPublisher 사용. 예제는 상속 클래스인 ApplicationContext
- Events: 디스패처를 사용. 이벤트를 발행
- 핸들러 : 스프링 제공 @EventListener 애너테이션을 이용, 이벤트 수신하여 처리

### 10.3.1 이벤트 클래스

이벤트 클래스 구현 예시

### 10.3.2 Events 클래스와 ApplicationEventPublisher

Events 클래스 구현 예시.

- aplicationEventPublisher(ApplicationContext)를 참조하여 이벤트 발생 시 publishEvent(event) 메서드를 실행시킨다.

### 10.3.3 이벤트 발생과 이벤트 핸들러

도메인 로직 및 핸들러 구현 예시

- 도메인 로직에서 이벤트 발생
- @EventListener 에너테이션을 이용해 핸들러 구현

### 10.3.4 흐름 정리

모든 프로세스는 **하나의 트랜잭션**에서 발생

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/5e77bd9c-316a-4e86-8082-6bc082cd2469/cbe55b1d-b265-4679-8dfa-1067048e9223/image.png)

## 10.4 동기 이벤트 처리 문제

- 위 내용들은 도메인 로직 뒤섞임을 방지하는 코드
- 트랜잭션 이슈, 성능 결합 이슈는 여전히 존재
- 두 가지 해결방법이 있음
    - 비동기 이벤트 처리
    - 이벤트와 트랜잭션 연계 (책에서는 안 다루는 것 같은데.. 모르겠음)

## 10.5 비동기로 이벤트 처리

별도 스레드로 이벤트 핸들러 처리

네 가지 방식 예시

- 로컬 핸들러를 비동기로 실행
- 메시지 큐 사용
- 이벤트 저장소와 이벤트 포워더 사용
- 이벤트 저장소와 이벤트 제공 API 사용

(관수)크게는 세 가지 방식으로 보면 될 것 같다.

- 로컬 핸들러를 비 동기로 실행
- 메시지 큐 사용
- 이벤트 저장소 이용

더 크게는 두 가지 방식으로 나뉜다.

- 동일 애플리케이션 ⇒ 로컬 핸들러 비 동기 실행
- 외부 애플리케이션 ⇒ 별도 저장소 사용

### 10.5.1 로컬 핸들러 비동기 실행

스프링이 제공하는 @EnableAsync 애너테이션과 @Async 애너테이션 사용

### 10.5.2 메시징 시스템을 이용한 비동기 구현

- 카프카 / 래빗MQ와 같은 메시지 큐 시스템 이용
- 퍼블리셔 : 메시지 발행
  ⇒ 메시지 큐 : 메시지 쌓임
  ⇒ 핸들러 : 메시지 큐에서 메시지 읽어서 처리
- 퍼블리셔와 핸들러가 각각 다른 트랜잭션에서 작동

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/5e77bd9c-316a-4e86-8082-6bc082cd2469/d054b7b8-6ba2-4bc4-b1ef-5bb4d145245e/image.png)

- 도메인 기능과 메시지를 저장하는 절차를 하나의 트랜잭션으로 처리하려면 글로벌 트랜잭션 필요.
  이는 기능 저하라는 단점이 있으며 일부 메시지 시스템에서만 제공.

### 10.5.3 이벤트 저장소를 이용한 비동기 처리

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/5e77bd9c-316a-4e86-8082-6bc082cd2469/36ff4181-3d67-4b00-8c93-bacc278026a1/image.png)

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/5e77bd9c-316a-4e86-8082-6bc082cd2469/c785420d-4729-4704-b443-0d4786170bdc/image.png)

- 이벤트를 로컬 핸들러를 이용하여 DB에 저장
- 이 때 DB는 도메인의 상태를 저장하는 DB와 동일한 것을 사용
- 두 가지 방식
    - API 방식: 외부 핸들러가 API를 통해서 이벤트 조회 후 처리
    - 포워더 방식: 포워더가 DB에서 값 조회, 이벤트 핸들러 호출
- 외부 클라이언트와 포워더는 이벤트 발생 및 저장 트랜잭션과 다른 트랜잭션에서 작동
- API 방식은 조회 추적 책임이 핸들러에서, 포워더 방식은 포워더에서 관리

***p325 ~ p336 은 코드 예시

- 모든 비동기 처리 방식에서 ApplicationEventPublisher를 활용하여 구현 가능.
- 자동 증가 칼럼은 사용 시 주의사항이 있으므로, ID 기준 데이터 지연 조회 방식을 추천함. p337 NOTE 참고.

## 10.6 이벤트 적용 시 추가 고려 사항

1. 이벤트 소스 추가 여부.
   추가 시 추적에 유리
2. 포워더 전송 실패 시 재 시도 횟수 조절.
3. 이벤트 손실.
   저장소 이용 방식을 사용하면 손실 걱정은 없음.
4. 이벤트 순서
   저장소 이용 방식을 사용하면 순서 보장 가능
5. 이벤트 재처리
    1. 순번 기억 후, 처리된 순번이 다시 오면 무시하는 방식 구현
    2. 멱등성을 보장하는 방식으로 구현

### 10.6.1 이벤트 처리와 DB 트랜잭션 고려

동기, 비동기 방식 모두 이벤트 재 처리와 DB 트랜잭션을 고려해야 한다.
경우의 수를 줄여나가는 방식으로 개발하자.

트랜잭션이 성공한 경우에만 이벤트가 발생하도록 경우의 수를 줄이는 방법 두 가지 예시 :

- 로컬 핸들러에 스프링 제공 @TransactionalEventListener 애너테이션 사용
- 이벤트 저장소 사용 시 자동 적용.

### 아래는 처음 정리 내용 기록입니다.

바운디드 컨텍스트 간 강결합을 방지할 수 있다.

스프링 프레임워크가 제공하는 어노테이션을 통해 간단하게 동기방식 이벤트 구조 구현이 가능. 하지만 이 때 트랜잭션 관리 이슈와 외부 시스템과의 강결합 이슈가 있음

비동기방식은 앱 내에서 async 어노테이션을 이용, 쓰레드를 분리하는 방식과 메시지, db 등 외부 인프라를 이용하는 방법이 있음.

로컬핸들러를 사용하냐 마냐에 따라 스프링에서 제공하는 이벤트 어노테이션을 적극 활용하는지, 안하는지가 결정될듯.

db 사용할 때 offset 관리할 때 pk를 사용한다면 자동컬럼증가 방식은 조심해야 함.

외부시스템 연동 시 트랜잭션 이슈는 항상 있음. @TransactionalEventListener(로컬 핸들러)에 after_commit 옵션을 비동기메시징을 함께 이용하면 트랜잭션 이슈를 해소할 수 있겠다. 이 때는 메시지 유실을 또 고려해야하네… 유실을 고려한다면 그러면 그냥 메시지 발행로직을 트랜잭션 맨 마지막에 둬도 되고. 결국 트랜잭션 라이프사이클을 동일하게 하면 메시지 유실을 막는 대신 발행과 서비스가 강결합되고, 다르게 한다면 메시지 유실을 고려해야함. 메시지와 서비스 강결합이 좋을 것 같음.

# 11장. CQRS

CQRS 개념과 장단점을 간략하게 설명

## 11.1 단일 모델의 단점

ORM 기법은 도메인 상태 변경 기능에는 적합하나, 여러 에그리거트에서 데이터를 가져와 출력하는 데는 고려할 요소가 많다.
따라서 하나의 모델로 표현하기 어려움.

- 식별자 참조 = JPA 최적화가 불가능해 쿼리가 많아짐
- 직접 참조 = 최적화가 가능하지만 조회 상황에 따라 다르게 적용할 수 없음

이런 고민을 방지하고 구현 복잡도를 해결하고자 커맨드 모델과 쿼리 모델을 분리한다.

## 11.2 CQRS

- 상태를 변경하는 범위와, 조회하는 범위가 정확하게 일치하지 않기 때문에 단일 모델로 구현하면 불필요하게 복잡해진다.
- 조회 범위가 넓어질 수록 다양한 JPA 성능 관련 기능을 적용해야 한다.
- 도메인이 복잡할 수록 불일치하는 범위가 커지므로 CQRS가 더욱 효과적이다.
- 모델을 분리하면 구현 기술 / 아키텍쳐 / 인프라(DB) 까지 모두 각 기능에 최적화되도록 적용할 수 있다.
- DB 분리 시 동기화 필요. 예시는 이벤트이며 동기/비동기 방식이 있다고 설명한다.
- CQRS 패턴을 적용하는 데 특별한 기술이 정해진 것은 아니다.

### 11.2.1 웹과 CQRS

- 일반적으로 웹에서는 조회 요청이 훨씬 많다.
- 조회 성능을 끌어올리기 위해서 ‘캐싱’, ‘쿼리 최적화’, ‘저장소 분리’등의 처리를 한다.
- 이 작업들은 결과적으로 CQRS 적용과 동일한 효과를 낸다.
- 이런 처리를 명시적으로 모델 구분으로 가져가자. 이를 통해 모델 복잡도를 낮추고 조회에 특화된 구현 기법을 보다 쉽게 적용할 수 있다.

### 1.2.2 CQRS 장단점

장점

1. 복잡한 상태 변경 로직과 다양한 조회 최적화 기법들이 분리돼 각 기능에 집중 가능
2. 조회 성능 최적화가 쉽고, 이 모든게 명령 모델에 영향을 미치지 않음
    1. 조회 단위로 캐시 적용
    2. 조회 전용 쿼리 작성
    3. 전문 db 분리

단점

1. 구현 코드가 많아짐.
2. 구현 기술이 많아짐

따라서 트레이드 오프를 잘 고려해야 함.

### 관수 정리

복잡한 도메인 로직과, (JPA ORM의)다양한 조회 최적화 기법을 하나의 모델에 구현하면 너무 복잡함.

이를 분리하면 로직이 분리되고 최적화가 더욱 쉬워진다.

더욱이 CQRS는 모델 구현 뿐 아니라 아키텍처, 인프라 구현 기술과 DB까지 분리가 가능케 하고 이는 조회 기능을 더욱 최적화 하기 좋게 만듬.

다만 구현 코드와 적용 기술이 많아지기 때문에 유지보수 비용과 초기 개발 비용 트레이드 오프를 잘 고려해야 함.

‘캐싱’, ‘쿼리 최적화’, ‘저장소 분리’ 등 조회 최적화 기법들이 모두 CQRS와 동일한 결과를 낸다. 따라서 이를 적용할 때 명시적으로 모델을 분리하는 걸 검토해보자.